<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>version = "0.9.7.2";
versiondate = "2015-01-26";

FS_gmfilesystem_initialize(1);
FS_set_gm_save_area("%appdata%\ildagen");
FS_set_working_directory("%appdata%\ildagen");

math_set_epsilon(0.00001);

varmap = ds_map_create();
parser_shape = ML_InitParserScience(varmap);
    ML_AddVariable(parser_shape, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "max",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_shape, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
varmap = ds_map_create();
parser_cb = ML_InitParserScience(varmap);
    ML_AddVariable(parser_cb, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchorx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchory",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "x",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "y",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "max",255, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_cb, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    

radialgrid_surf = surface_create(512,512);
surface_set_target(radialgrid_surf);
    draw_radialgrid();
surface_reset_target();
squaregrid_surf = surface_create(512,512);
surface_set_target(squaregrid_surf);
    draw_grid();
surface_reset_target();

update_verbose = 0;
serial = "";
frame_surf_refresh = 0;
refresh_miniaudio_flag = 1;
letter = "";
el_list = ds_list_create();
undo_list = ds_stack_create();
el_id = 0;
frame_surf = surface_create(512,512);
frame3d_surf = surface_create(512,512);
frame_list = ds_list_create();
ds_list_add(frame_list,el_list);
free_list = ds_list_create();
bez_list = ds_list_create();
font_list = ds_list_create();
xdelta[32] = 0;
snap_list = ds_list_create();
selsurf = surface_create(512,512);
miniaudio_surf = surface_create(512,512);
copy_list = -1;
selectedelementlist = ds_list_create();
projectfps = 30;

redraw = 0;
sgridshow = 0;
rgridshow = 0;
sgriddouble = 0;
rgriddouble = 0;

mouse_yprevious = mouse_y;
mouse_xprevious = mouse_x;

phi = 1.618;
tlw = 512;
tlh = 42;

tooltip = "";
bckimage = 0;
onion = 0;
onion_dropoff = 0.7;
onion_number = 2;
onion_alpha = 0.8;
scroll = 0;
viewmode = 0;
selectedelement = -1;
selectedelementlist = 0;
exp_optimize = 0;
getint = -1;
getstr = -1;
dialog = "";
selecting = 0;
scroll = 0;

opt_maxdist = 2048;

placing = "line";
startpos[1] = 0;
placing_status = 0;
wave_amp = 10000;
wave_period = 1;
pointx[20] = 0;
pointy[20] = 0;
wave_offset = 0;
bez_moving = 0;
font_size = 20;

resolution = "auto";
framepoints = 0;

reap_color = 1;
reap_blank = 1;
reap_removeoverlap = 0;
reap_trans = 1;
reap_preserveblank = 1;
reap_interpolate = 1;

colormode = "solid";
colormode2 = 0;
color1 = c_white;
color2 = c_white;
enddotscolor = c_red;
color_period = 8192;
color_freq = 1;
color_dc = 0.5;
color_offset = 0;
color_blendmode = 0; //0 replace 1 add 2 subtract

blankmode = "solid";
blankmode2 = 0;
blank_period = 8192;
blank_dc = 0.5;
blank_freq = 4;
enddots = 0;
makedot = 0;
dotmultiply = 20;
blank_offset = 0;

anienable = 0;
frame = 0;
framehr = 0;
fillframes = 1;
maxframes = 1;
anicolor1 = c_white;
anicolor2 = c_white;
anienddotscolor = c_red;
anicolor_dc = 0.5;
aniblank_dc = 0.5;
aniblank_offset = 0;
anicolor_offset = 0;
aniwave_offset = 0;
anifunc = "saw";
aniwave_amp = 10000;

rot = 0;
anirot = 0;
scalex = 1;
scaley = 1;
aniscalex = 1;
aniscaley = 1;
anchorx = $8000;
anchory = $8000;
anixtrans = 0;
aniytrans = 0;
shaking = 0;
shaking_sdev = 5;
scope_start = 0;
scope_end = 0;
objmoving = 0;

shapefunc_cp = 100;
shapefunc_string_x = "";
shapefunc_string_y = "";
colorfunc_string_1 = "";
colorfunc_string_2 = "";
colorfunc_string_3 = "";
blankfunc_string = "";


if (os_version != -1) init_palette();
if (os_version != -1) update_check();
if (os_version != -1) parse_parameter();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
sgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
rgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
scroll = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

with (obj_cursor)
    {
    if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
        {
        image_index = 8;
        x = clamp(mouse_x,0,view_wview[0]-128);
        y = clamp(mouse_y,0,view_hview[0]-128);
        }
    else
        {
        x = mouse_x;
        y = mouse_y;
        }
    }

if (ds_list_size(el_list) &gt; 0)
    {
    if (keyboard_check(vk_alt) and (placing_status == 0))
        {
        if (keyboard_check(vk_control))
            {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),0)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),1)/128;
            }
        else
            {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),2)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),3)/128;
            }
        }
    else if (keyboard_check(ord('Q')))
        {
        nearestdist = 32;
        for (i = 0;i &lt; ds_list_size(el_list);i++)
            {
            templist =  ds_list_find_value(el_list,i);
            if (point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y) &lt; nearestdist)
                {
                obj_cursor.x = ds_list_find_value(templist,0)/128;
                obj_cursor.y = ds_list_find_value(templist,1)/128;
                nearestdist = point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y);
                }
            if (point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y) &lt; nearestdist)
                {
                obj_cursor.x = ds_list_find_value(templist,2)/128;
                obj_cursor.y = ds_list_find_value(templist,3)/128;
                nearestdist = point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y);
                }
            }
        
        }
    }
    
if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
    {
    view_visible[2] = 1;
    view_xport[2] = clamp(obj_cursor.x-128,0,view_wview[0]-256);
    view_yport[2] = clamp(obj_cursor.y-128,0,view_hview[0]-256);
    }
else
    view_visible[2] = 0;
    
if (keyboard_check(ord('S'))) or (sgridshow == 1)
    with (obj_cursor)
        move_snap(32,32);
        
if (keyboard_check_released(vk_f11))
    window_set_fullscreen(!window_get_fullscreen())
    
if (keyboard_check_pressed(ord('M')))
    {
    window_set_fullscreen(0);
    window_set_size(1100,670);
    }
        
if (keyboard_check_pressed(vk_backspace))
    {
    placing_status = 0;
    selectedelement = -1;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }
    
if (keyboard_check_pressed(vk_space))
    {
    viewmode++;
    if (viewmode &gt; 2)
        viewmode = 0;
    frame_surf_refresh = 1;
    }
    
if (!surface_exists(frame_surf) || (!surface_exists(frame3d_surf) &amp;&amp; viewmode != 0))
    frame_surf_refresh = 1;
    
if (keyboard_check(vk_control)) and ds_list_size(el_list)
    {
    check_elementselect();
    }
    
//PASTE
if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('V')))
    {
    if (copy_list == -1)
        exit;
        
    changese = 0;
    for (u = 0;u &lt; ds_list_size(copy_list);u++)
        {
        list = ds_list_create();
        ds_list_copy(list,ds_list_find_value(copy_list,u));
        if (u == 0)
            firstframe = ds_list_find_value(list,ds_list_size(list)-1);
        framei = frame+ds_list_find_value(list,ds_list_size(list)-1)-firstframe;
        if (framei &gt; maxframes-1)
            {
            ds_list_destroy(list);
            break;
            }
        if (frame == framei)
            {
            changese = 1;
            selectedelementlist = list;
            }
        ds_list_delete(list,ds_list_size(list)-1);
        ds_list_replace(list,9,el_id);
        el_list = ds_list_find_value(frame_list,framei);
        show_debug_message(framei);
        ds_list_add(el_list,list);
        }    
        
    if (changese)
        selectedelement = el_id;
    ds_stack_push(undo_list,el_id);
    el_id++;
    
    if (changese)
        {
        xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
        yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
        rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
        rectymin = yo + (ds_list_find_value(selectedelementlist,6));
        rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
        rectymax = yo + (ds_list_find_value(selectedelementlist,7));
        }
    
    frame_surf_refresh = 1;
    }
    
//SELECTED ELEMENT STUFFS
if (selectedelement != -1)
    {
    handle_trans();
    
    //COPY
    if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('C')))
        {
        if (copy_list != -1)
            ds_list_destroy(copy_list);
            
        copy_list = ds_list_create();
        if (fillframes)
            {
            for (j = scope_start;j &lt;= scope_end;j++)
                {
                el_list = ds_list_find_value(frame_list,j);
                for (i = 0;i &lt; ds_list_size(el_list);i++)
                    {
                    if (ds_list_find_value(ds_list_find_value(el_list,i),9) == selectedelement)
                        {
                        list_id = ds_list_find_value(el_list,i);
                        temp_undo_list = ds_list_create();
                        ds_list_copy(temp_undo_list,list_id);
                        ds_list_add(temp_undo_list,j);
                        ds_list_add(copy_list,temp_undo_list);
                        }
                    }
                }
            }
        else
            {
            el_list = ds_list_find_value(frame_list,frame);
            
            list_id = selectedelementlist;
            copy_list = ds_list_create();
            ds_list_copy(temp_undo_list,list_id);
            ds_list_add(temp_undo_list,frame);
            ds_list_add(copy_list,temp_undo_list);
            }
        
        
        placing_status = 0;
        ds_list_clear(free_list);
        ds_list_clear(bez_list);
        }
        
    //CUT
    if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('X')))
        {
        if (copy_list != -1)
            ds_list_destroy(copy_list);
            
        copy_list = ds_list_create();
        if (fillframes)
            {
            for (j = scope_start;j &lt;= scope_end;j++)
                {
                el_list = ds_list_find_value(frame_list,j);
                for (i = 0;i &lt; ds_list_size(el_list);i++)
                    {
                    if (ds_list_find_value(ds_list_find_value(el_list,i),9) == selectedelement)
                        {
                        list_id = ds_list_find_value(el_list,i);
                        temp_undo_list = ds_list_create();
                        ds_list_copy(temp_undo_list,list_id);
                        ds_list_add(temp_undo_list,j);
                        ds_list_add(copy_list,temp_undo_list);
                        ds_list_destroy(list_id);
                        ds_list_delete(el_list,i);
                        }
                    }
                }
            }
        else
            {
            el_list = ds_list_find_value(frame_list,frame);
            
            list_id = selectedelementlist;
            temp_undo_list = ds_list_create();
            ds_list_copy(temp_undo_list,list_id);
            ds_list_add(temp_undo_list,frame);
            ds_list_add(copy_list,temp_undo_list);
            ds_list_delete(el_list,ds_list_find_index(el_list,list_id));
            ds_list_destroy(list_id);
            }
            
        frame_surf_refresh = 1;
        
        placing_status = 0;
        selectedelement = -1;
        ds_list_clear(free_list);
        ds_list_clear(bez_list);
        }
        
    //DELETE
    if (keyboard_check_pressed(vk_delete))
        {
        temp_undof_list = ds_list_create();
        if (fillframes)
            {
            for (j = scope_start;j &lt;= scope_end;j++)
                {
                el_list = ds_list_find_value(frame_list,j);
                for (i = 0;i &lt; ds_list_size(el_list);i++)
                    {
                    if (ds_list_find_value(ds_list_find_value(el_list,i),9) == selectedelement)
                        {
                        list_id = ds_list_find_value(el_list,i);
                        temp_undo_list = ds_list_create();
                        ds_list_copy(temp_undo_list,list_id);
                        ds_list_add(temp_undo_list,j);
                        ds_list_add(temp_undof_list,temp_undo_list);
                        ds_list_destroy(list_id);
                        ds_list_delete(el_list,i);
                        }
                    }
                }
            }
        else
            {
            el_list = ds_list_find_value(frame_list,frame);
            
            list_id = selectedelementlist;
            temp_undo_list = ds_list_create();
            ds_list_copy(temp_undo_list,list_id);
            ds_list_add(temp_undo_list,frame);
            ds_list_add(temp_undof_list,temp_undo_list);
            ds_list_delete(el_list,ds_list_find_index(el_list,list_id));
            ds_list_destroy(list_id);
            }
            
        ds_stack_push(undo_list,"l"+string(temp_undof_list));
        frame_surf_refresh = 1;
        
        placing_status = 0;
        selectedelement = -1;
        ds_list_clear(free_list);
        ds_list_clear(bez_list);
        }
    }


    
//KEYBOARD RIGHT LEFT
if (keyboard_check(vk_left)) and (maxframes &gt; 1) and (placing_status == 0)
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_left))
        {
        frame--;
        framehr--;
        scroll = 0;
        alarm[0] = 30;
        }
    else if (scroll)
        framehr -= delta_time/1000000*seqcontrol.projectfps;
    if (framehr &lt; -0.5)
        framehr+= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    frame_surf_refresh = 1;
    
    if (selectedelement != -1)
        {
        sefound = 0;
        for (i = 0; i &lt; ds_list_size(el_list);i++)
            {
            if (selectedelement = ds_list_find_value(ds_list_find_value(el_list,i),9))
                {
                sefound = 1;
                selectedelementlist = ds_list_find_value(el_list,i);
                xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
                yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
                rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
                rectymin = yo + (ds_list_find_value(selectedelementlist,6));
                rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
                rectymax = yo + (ds_list_find_value(selectedelementlist,7));
                }
            }
        if (sefound == 0)
            selectedelement = -1;
        }
    }
else if (keyboard_check(vk_right)) and (maxframes &gt; 1) and (placing_status == 0)
    {

    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_right))
        {
        frame++;
        framehr++;
        scroll = 0;
        alarm[0] = 30;
        }
    else if (scroll)
        framehr += delta_time/1000000*seqcontrol.projectfps;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    frame_surf_refresh = 1;
    
    if (selectedelement != -1)
        {
        sefound = 0;
        for (i = 0; i &lt; ds_list_size(el_list);i++)
            {
            if (selectedelement = ds_list_find_value(ds_list_find_value(el_list,i),9))
                {
                sefound = 1;
                selectedelementlist = ds_list_find_value(el_list,i);
                xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
                yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
                rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
                rectymin = yo + (ds_list_find_value(selectedelementlist,6));
                rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
                rectymax = yo + (ds_list_find_value(selectedelementlist,7));
                }
            }
        if (sefound == 0)
            selectedelement = -1;
        }
    }
    
if (frame &gt;= maxframes)
    {
    frame = maxframes-1;
    framehr = maxframes-1;
    }
    
//KEYBOARD UP DOWN
if (keyboard_check_pressed(vk_up)) and (!ds_list_empty(el_list)) and (placing_status == 0)
    {
    tempstop = 0;
    while (1)
        {
        selectedelement++;
        for (i = 0; i &lt; ds_list_size(el_list);i++)
            {
            if (selectedelement = ds_list_find_value(ds_list_find_value(el_list,i),9))
                {
                tempstop = 1;
                selectedelementlist = ds_list_find_value(el_list,i);
                xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
                yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
                rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
                rectymin = yo + (ds_list_find_value(selectedelementlist,6));
                rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
                rectymax = yo + (ds_list_find_value(selectedelementlist,7));
                }
            }
        if (tempstop)
            {
            placing_status = 0;
            ds_list_clear(free_list);
            ds_list_clear(bez_list);
            exit;
            }
            
        
        if (selectedelement &gt; el_id)
            {
            selectedelement = -1;
            exit;
            }
        }
    }
    
if (keyboard_check_pressed(vk_down)) and (!ds_list_empty(el_list)) and (placing_status == 0)
    {
    tempstop = 0;
    while (1)
        {
        selectedelement--;
        for (i = 0; i &lt; ds_list_size(el_list);i++)
            {   
            if (selectedelement = ds_list_find_value(ds_list_find_value(el_list,i),9))
                {
                tempstop = 1;
                selectedelementlist = ds_list_find_value(el_list,i);
                xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
                yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
                rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
                rectymin = yo + (ds_list_find_value(selectedelementlist,6));
                rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
                rectymax = yo + (ds_list_find_value(selectedelementlist,7));
                }
            }
        if (tempstop)
            {
            placing_status = 0;
            ds_list_clear(free_list);
            ds_list_clear(bez_list);
            exit;
            }
        
        if (selectedelement &lt; 0)
            {
            selectedelement = -1;
            exit;
            }
        }
    }
    
if (keyboard_check_pressed(vk_tab))
    {
    if (os_version == -1)
        {
        show_message_async("Sorry, this timeline is not available in the web version");
        exit;
        }
        
    room_goto(rm_seq);
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if ((mouse_x &gt; 550) or (mouse_y &gt; 550)) and (placing_status != 2) or ((selectedelement != -1)  and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
))
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }

if (placing_status == 1) and (placing != "text")
    {
    if (placing != "curve")
        create_element();
    else
        {
        placing_status = 2;
        point1x = startpos[0]+cos(-mousedir-pi/2)*100;
        if (point1x &gt; 500) or (point1x &lt; 10)
            point1x = startpos[0]+cos(-mousedir+pi/2)*100;
        point1y = startpos[1]+sin(-mousedir-pi/2)*100;
        if (point1y &gt; 500) or (point1y &lt; 10)
            point1y = startpos[1]+sin(-mousedir+pi/2)*100;
        point2x = endx+cos(-mousedir-pi/2)*100;
        if (point2x &gt; 500) or (point2x &lt; 10)
            point2x = endx+cos(-mousedir+pi/2)*100;
        point2y = endy+sin(-mousedir-pi/2)*100;
        if (point2y &gt; 500) or (point2y &lt; 10)
            point2y = endy+sin(-mousedir+pi/2)*100;
        ds_list_replace(bez_list,2,point1x);
        ds_list_replace(bez_list,3,point1y);
        ds_list_replace(bez_list,4,point2x);
        ds_list_replace(bez_list,5,point2y);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    }
    
bez_moving = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (instance_exists(oDropDown)) or (mouse_x &gt; 512) or (mouse_y &gt; 512) or (keyboard_check(vk_control))
    exit;

if (selectedelement != -1)  and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
)
    exit;
    
selectedelement = -1;

if ((keyboard_check(ord('E'))) and (placing_status != 2))
    {
    ds_stack_push(undo_list,"bb"+string(color2));
    ds_stack_push(undo_list,"b"+string(color1));
    color1 = draw_getpixel(obj_cursor.x,obj_cursor.y);
    exit;
    }

if ((mouse_x &gt; 515) or (mouse_y &gt; 515)) and (placing_status != 2)
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }
    
    
if (placing_status == 0)
    {
    placing_status = 1;
    startpos[0] = obj_cursor.x;
    startpos[1] = obj_cursor.y;
    if (placing == "text")
        create_text_init();
    else if (placing == "free")
        {
        ds_list_add(free_list,0);
        ds_list_add(free_list,0);
        }
    else if (placing == "curve")
        {
        bezier_coeffs(0,0,0,0,0,0,0,0);
        ds_list_add(bez_list,startpos[0]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        }
    }
    
else if (placing_status == 2) and (placing == "curve")
    {
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3)) &lt; 7)
        bez_moving = 1;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5)) &lt; 7)
        bez_moving = 2;
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1)) &lt; 7)
        bez_moving = 3;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7)) &lt; 7)
        bez_moving = 4;
    mouse_yprevious = mouse_y;
    mouse_xprevious = mouse_x;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (mouse_x &gt; 512) or (mouse_y &gt; 512)
    exit;


//selectedelement = -1;
    
if (placing == "free")
    {
    if (placing_status == 1)
        {
        autoresflag = 0;
        if (is_string(resolution)) 
            {
            autoresflag = 1; 
            resolution = 512;
            }
        if (point_distance(startpos[0]+ds_list_find_value(free_list,ds_list_size(free_list)-2),startpos[1]+ds_list_find_value(free_list,ds_list_size(free_list)-1),mouse_x,mouse_y) &gt;= resolution/128)
            {
            ds_list_add(free_list,mouse_x-startpos[0]);
            ds_list_add(free_list,mouse_y-startpos[1]);
            }
        if (autoresflag)
            resolution = "auto";
        }
    }
else if (placing == "curve")
    {
    if (placing_status == 1)
        {
        mousedir = degtorad(point_direction(startpos[0],startpos[1],endx,endy));
        ds_list_replace(bez_list,6,endx);
        ds_list_replace(bez_list,7,endy);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    else if (placing_status == 2)
        {
        if (bez_moving == 1)
            {
            ds_list_replace(bez_list,2,ds_list_find_value(bez_list,2)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,3,ds_list_find_value(bez_list,3)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 2)
            {
            ds_list_replace(bez_list,4,ds_list_find_value(bez_list,4)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,5,ds_list_find_value(bez_list,5)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 3)
            {
            ds_list_replace(bez_list,0,ds_list_find_value(bez_list,0)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,1,ds_list_find_value(bez_list,1)+mouse_y-mouse_yprevious);
            startpos[0] = ds_list_find_value(bez_list,0);
            startpos[1] = ds_list_find_value(bez_list,1);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 4)
            {
            ds_list_replace(bez_list,6,ds_list_find_value(bez_list,6)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,7,ds_list_find_value(bez_list,7)+mouse_y-mouse_yprevious);
            endx = ds_list_find_value(bez_list,6);
            endy = ds_list_find_value(bez_list,7);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        }
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//what a mess

//Get integer
var new_id = ds_map_find_value(async_load, "id");
if (new_id == getint)
    {
    if (dialog == "update")
        {
        updatecheckenabled = ds_map_find_value(async_load, "status");
        ini_open(ini_filename);
        ini_write_real("main","updatecheck",updatecheckenabled);
        ini_close();
        if (updatecheckenabled)
            {
            updateget = http_get("http://github.com/Grix/ildagen/raw/master/version.txt");
            }
        }
    if (dialog == "updatefound")
        {
        if (ds_map_find_value(async_load, "status"))
            url_open("http://bitlasers.com/opencart/index.php?route=product/product&amp;path=67&amp;product_id=82");
        }        

    if ds_map_find_value(async_load, "status")
       {
      switch (dialog)
          {
          case "wavet":
            {
            wave_period = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "waveamp":
            {
            wave_amp = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "waveoffset":
            {
            wave_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "shapefuncpoints":
            {
            shapefunc_cp = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "colorfreq":
            {
            color_freq = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "colordc":
            {
            color_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
            
            break;
            }
          case "colorperiod":
            {
            color_period = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "coloroffset":
            {
            color_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "blankoffset":
            {
            blank_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "blankdc":
            {
            blank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
            
            break;
            }
          case "aniblankdc":
            {
            aniblank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
            
            break;
            }
          case "blankperiod":
            {
            blank_period = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "blankfreq":
            {
            blank_freq = ds_map_find_value(async_load, "value");
            
            break;
            }
            
          //ANI
          case "aniblankoffset":
            {
            aniblank_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "anicolordc":
            {
            anicolor_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
            
            break;
            }
          case "anicoloroffset":
            {
            anicolor_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "aniwaveoffset":
            {
            aniwave_offset = ds_map_find_value(async_load, "value");
            
            break;
            }
          case "aniwaveamp":
            {
            aniwave_amp = ds_map_find_value(async_load, "value");
            
            break;
            }
            
            //COLOR
          case "c1r":
            {
            color1 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color1),colour_get_blue(color1));
            
            break;
            }
          case "c1g":
            {
            color1 = make_color_rgb(colour_get_red(color1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color1));
            
            break;
            }
          case "c1b":
            {
            color1 = make_color_rgb(colour_get_red(color1),colour_get_green(color1),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
          case "c2r":
            {
            color2 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color2),colour_get_blue(color2));
            
            break;
            }
          case "c2g":
            {
            color2 = make_color_rgb(colour_get_red(color2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color2));
            
            break;
            }
          case "c2b":
            {
            color2 = make_color_rgb(colour_get_red(color2),colour_get_green(color2),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
          case "c3r":
            {
            enddotscolor = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(enddotscolor),colour_get_blue(enddotscolor));
            
            break;
            }
          case "c3g":
            {
            enddotscolor = make_color_rgb(colour_get_red(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(enddotscolor));
            
            break;
            }
          case "c3b":
            {
            enddotscolor = make_color_rgb(colour_get_red(enddotscolor),colour_get_green(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
            //ANI COLOR
          case "ac1r":
            {
            anicolor1 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor1),colour_get_blue(anicolor1));
            
            break;
            }
          case "ac1g":
            {
            anicolor1 = make_color_rgb(colour_get_red(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor1));
            
            break;
            }
          case "ac1b":
            {
            anicolor1 = make_color_rgb(colour_get_red(anicolor1),colour_get_green(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
          case "ac2r":
            {
            anicolor2 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor2),colour_get_blue(anicolor2));
            
            break;
            }
          case "ac2g":
            {
            anicolor2 = make_color_rgb(colour_get_red(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor2));
            
            break;
            }
          case "ac2b":
            {
            anicolor2 = make_color_rgb(colour_get_red(anicolor2),colour_get_green(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
          case "ac3r":
            {
            anienddotscolor = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anienddotscolor),colour_get_blue(anienddotscolor));
            
            break;
            }
          case "ac3g":
            {
            anienddotscolor = make_color_rgb(colour_get_red(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anienddotscolor));
            
            break;
            }
          case "ac3b":
            {
            anienddotscolor = make_color_rgb(colour_get_red(anienddotscolor),colour_get_green(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
            
            break;
            }
            
            
          case "anirot":
            {
            anirot = ds_map_find_value(async_load, "value");
            reapply_trans();
            
            xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
            yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
            rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
            rectymin = yo + (ds_list_find_value(selectedelementlist,6));
            rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
            rectymax = yo + (ds_list_find_value(selectedelementlist,7));
            
            break;
            }
          
          case "clearall":
            {
            placing_status = 0;
            ds_list_clear(free_list);
            ds_list_clear(bez_list);
            selectedelement = -1;
            
            for (j = 0;j &lt; ds_list_size(frame_list);j++)
                {
                el_list = ds_list_find_value(frame_list,j);
                for (i = 0;i &lt; ds_list_size(el_list);i++)
                    {
                    list_id = ds_list_find_value(el_list,i);
                    ds_list_destroy(list_id);
                    }
                ds_list_clear(el_list);
                }
                
            
            framepoints = 0;
            frame = 0;
            framehr = 0;
            maxframes = 1;
            scope_start = 0;
            scope_end = maxframes-1;
            refresh_miniaudio_flag = 1;
            
            frame_surf_refresh = 1;
            
            break;
            }
            
          case "loadfile":
            {
            load_frames(get_open_filename_ext("ildaGen frames|*.igf","","","Select ildaGen frames file"));
            
            break;
            }
          
          case "dotintensity":
            {
            ds_stack_push(undo_list,"d"+string(dotmultiply))

            dotmultiply = ds_map_find_value(async_load, "value");
            if (dotmultiply &lt; 1) dotmultiply = 1;
            if (dotmultiply &gt; 32) dotmultiply = 32;
            
            break;
            }
          case "onion_number":
            {
            onion_number = ds_map_find_value(async_load, "value");
            frame_surf_refresh = 1;
            
            break;
            }
          case "onion_alpha":
            {
            onion_alpha = clamp(ds_map_find_value(async_load, "value"),0,1);
            frame_surf_refresh = 1;
            
            break;
            }
          case "onion_dropoff":
            {
            onion_dropoff = clamp(ds_map_find_value(async_load, "value"),0,1);
            frame_surf_refresh = 1;
            
            break;
            }
          case "fontsize":
            {
            font_size = clamp(ds_map_find_value(async_load, "value"),1,128);
            break;
            }
            
          case "res":
            {
            ds_stack_push(undo_list,"r"+string(resolution))

            resolution = ds_map_find_value(async_load, "value");
            if (resolution &lt; 4) resolution = 4;
            if (resolution &gt; $8000) resolution = $8000;
            
            break;
            }
            
          case "scopestart":
            {
            scope_start = clamp(ds_map_find_value(async_load, "value")-1,0,scope_end-1);
            frame = scope_start;
            framehr = scope_start;
            frame_surf_refresh = 1;
            refresh_miniaudio_flag = 1;
            
            break;
            }
            
          case "scopeend":
            {
            scope_end = clamp(ds_map_find_value(async_load, "value")-1,scope_start+1,maxframes-1);
            refresh_miniaudio_flag = 1;
            
            break;
            }
            
          case "fps":
            {
            seqcontrol.projectfps = clamp(ds_map_find_value(async_load, "value"),1,999);
            projectfps = seqcontrol.projectfps;
            refresh_miniaudio_flag = 1;
            
            break;
            }
            
          case "shake":
            {
            ds_stack_push(undo_list,"x"+string(shaking_sdev))
            
            shaking_sdev = ds_map_find_value(async_load, "value");
            if (shaking_sdev &lt; 0.1) shaking_sdev = 0.1;
            if (shaking_sdev &gt; 512) shaking_sdev = 512;
            
            break;
            }
            
          case "maxframes":
            {
            ds_stack_push(undo_list,"a"+string(maxframes))
            
            refresh_miniaudio_flag = 1;
            
            scopeflag = 0;
            if (maxframes == (scope_end+1)) scopeflag = 1;
            
            maxframes = ds_map_find_value(async_load, "value");
            
            if (maxframes &lt; 1) maxframes = 1;
            else if (maxframes &gt; $ffff) maxframes = $ffff;
            
            if (scopeflag) or (scope_end &gt;= maxframes) 
                scope_end = maxframes-1;
            
            if (scope_start &gt;= scope_end)
                scope_start = scope_end-1;
                
            if (scope_start &lt; 0) scope_start = 0;
            
            if (ds_list_size(frame_list) &lt; maxframes)
                repeat (maxframes - ds_list_size(frame_list))
                    {
                    templist = ds_list_create();
                    if (fillframes)
                        {
                        tempelcount = ds_list_size(ds_list_find_value(frame_list,ds_list_size(frame_list)-1));
                        for (u = 0;u &lt; tempelcount;u++)
                            {
                            tempellist = ds_list_create();
                            ds_list_copy(tempellist,ds_list_find_value(ds_list_find_value(frame_list,ds_list_size(frame_list)-1),u));
                            ds_list_add(templist,tempellist);
                            }
                        }
                    ds_list_add(frame_list,templist);
                    }
            /*else
                repeat (ds_list_size(frame_list)-maxframes)
                    {
                    el_list_temp = ds_list_find_value(frame_list,ds_list_size(frame_list)-1);
                    //for (u = 0;u &lt; ds_list_size(el_list_temp);u++)
                    //    ds_list_destroy(ds_list_find_value(el_list_temp,u));
                    ds_list_destroy(el_list_temp);
                    }*/
            if (frame &gt; maxframes) 
                {
                frame = maxframes-1;
                framehr = maxframes-1;
                }
                
            dd_scope_reset();
            
            break;
            }
            
          }
       }
    }
else if (new_id == getstr)
    {
    if ds_map_find_value(async_load, "status")
       {
      if ds_map_find_value(async_load, "result") != ""
          {
          switch (dialog)
            {
            case ("funcx"):
                {
                shapefunc_string_x = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcy"):
                {
                shapefunc_string_y = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func1"):
                {
                colorfunc_string_1 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func2"):
                {
                colorfunc_string_2 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func3"):
                {
                colorfunc_string_3 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcen"):
                {
                blankfunc_string = ds_map_find_value(async_load, "result");
                break;
                }
            case ("text"):
                {
                text = ds_map_find_value(async_load, "result");

                for (i = 0;i &lt;= maxframes;i++)
                    xdelta[i] = 0;
                
                //start making elements
                for (texti = 1; texti &lt;= string_length(text);texti++)
                    {
                    letter = string_char_at(text,texti);
                    if (ord(letter) != clamp(ord(letter),33,126))
                        {
                        for (i = 0;i &lt;= maxframes;i++)
                            xdelta[i] += font_size*1.3;
                        }
                    else
                        {
                        create_element();
                        }
                    }
                    
                frame_surf_refresh = 1;
                break;
                }
            case ("exporthtml5"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                export_ilda_html5();
                break;
                }
            case ("saveframes"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                save_frames_html5();
                break;
                }
            case ("serial"):
                {
                serial = ds_map_find_value(async_load, "result");
                with (obj_export)
                    {
                    controller.serialfile = file_text_open_write(working_directory+"serial");
                    file_text_write_string(controller.serialfile,controller.serial);
                    file_text_close(controller.serialfile);
                    show_message_async("Registered successfully");
                    }
                break;
                }
            }
          }
      }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!updatecheckenabled)
    exit;
    
if ds_map_find_value(async_load, "id") == updateget
    {
    if ds_map_find_value(async_load, "status") == 0
       {
       versionnew = ds_map_find_value(async_load, "result");
       show_debug_message("Checking version")
       if (versionnew != version)
            {
            getint = show_question_async("New version available: "+versionnew+"##Would you like to visit the download page?")
            dialog = "updatefound";
            }
       else if (update_verbose == 1)
            {
            show_message_async("Current version is up to date.");
            }
       }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//to free the system
FMODfree();
UnloadFMOD();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (tooltip != "")
    {
    draw_set_alpha(0.7);
    draw_set_color(c_black);
    draw_rectangle(0,0,string_width(tooltip)+20,string_height(tooltip)+10,0);
    draw_set_color(c_white);
    draw_set_alpha(1);
    draw_text(5,5,tooltip);
    tooltip = "";
    }
/*

if (room != rm_ilda) exit;

draw_set_alpha(0.8);
draw_set_font(fnt_tooltip);
draw_set_color(c_ltgray);
draw_text(12,495,"Frame: "+string(frame+1)+"/"+string(maxframes));
//draw_text(440,492,"Points: "+string(framepoints));
if (!anienable) and (maxframes &lt; 2)
    draw_set_color(c_dkgray);
else draw_set_color(c_ltgray);
if (scope_start == 0) and (scope_end == maxframes-1)
    draw_text(220,495,"Scope: All frames");
else
    draw_text(220,495,"Scope: "+string(scope_start+1)+" - "+string(scope_end+1));

/*draw_set_alpha(0.5);
draw_set_color(c_gray);
draw_line(12,508,512-12,508);
draw_line(12,509,512-12,509);
draw_set_color(c_teal);
draw_line(lerp(12,512-12,scope_start/(maxframes-1)),508,lerp(12,512-12,scope_end/(maxframes-1)),508);
draw_line(lerp(12,512-12,scope_start/(maxframes-1)),509,lerp(12,512-12,scope_end/(maxframes-1)),509);
draw_set_color(c_yellow);
draw_line(lerp(12,512-12,frame/(maxframes-1)),511,lerp(12,512-12,frame/(maxframes-1)),505);
draw_line(lerp(12,512-12,frame/(maxframes-1))+1,511,lerp(12,512-12,frame/(maxframes-1))+1,505);*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

if (!surface_exists(miniaudio_surf) || refresh_miniaudio_flag)
    {
    refresh_miniaudio_surf();
    refresh_miniaudio_flag = 0;
    }
    
draw_set_color(c_white);
draw_set_alpha(1);
if (surface_exists(miniaudio_surf))
    draw_surface_part(miniaudio_surf,0,0,tlw,tlh,0,515);
if (maxframes &gt; 1)
    {
    draw_set_color(c_black);
    cursorlinex = lerp(2,510,frame/(maxframes-1))//framehr/projectfps/1000;//framehr/1000*projectfps;
    draw_line(cursorlinex,515,cursorlinex,515+tlh-13);
    }
draw_set_color(c_white);

if (bckimage)
    {
    if (!keyboard_check(ord('E')))
        draw_set_alpha(0.3);
    if (sprite_exists(bck_bckimage))
        draw_sprite_stretched(bck_bckimage,0,0,0,512,512);
    else bckimage = 0;
    }
    
if (tooltip == "Click to select this object")
    {
    draw_set_alpha(0.5);
    draw_set_colour(c_teal);
        draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
    draw_set_alpha(1);
    draw_set_colour(c_white);
    }

draw_set_color(c_gray);
if (objmoving == 3)
    draw_text(20,20,string_format(anirot,3,2)+" deg");
else if (objmoving == 1)
    {
    draw_text(20,20,"X translation: "+string_format(anixtrans,5,0));
    draw_text(20,40,"Y translation: "+string_format(aniytrans,5,0));
    }
else if (objmoving == 2)
    {
    draw_text(20,20,"Anchor X: "+string_format(anchorx,5,0));
    draw_text(20,40,"Anchor Y: "+string_format(anchory,5,0));
    }
else if (objmoving == 4)
    {
    draw_text(20,20,"X scale: "+string_format(scalex,2,3));
    draw_text(20,40,"Y scale: "+string_format(scaley,2,3));
    }
draw_set_color(c_white);
    
draw_set_alpha(1);

if (keyboard_check(ord('A')))
    draw_guidelines();
    
if (keyboard_check(ord('S')) or (sgridshow == 1))
    {
    draw_surface(squaregrid_surf,0,0);
    if  (keyboard_check_pressed(ord('S')))
        {
        if (sgriddouble == 1)
            sgridshow = !sgridshow;
        alarm[2] = 40;
        sgriddouble = 1;
        }
    }
    
if (keyboard_check(ord('R')) or (rgridshow == 1))
    {
    draw_surface(radialgrid_surf,0,0);
    if  (keyboard_check_pressed(ord('R')))
        {
        if (rgriddouble == 1)
            rgridshow = !rgridshow;
        alarm[1] = 40;
        rgriddouble = 1;
        }
    }
    
draw_set_color(c_white);
    draw_ilda_2d();
    
draw_set_color(c_aqua);
if (selectedelement != -1)
    {
    draw_sprite(spr_anchor,0,anchorx/$ffff*512,anchory/$ffff*512);
    draw_set_alpha(0.6);
    draw_sprite(spr_rotate,0,rectxmin,rectymax);
    draw_sprite(spr_resize,0,rectxmax,rectymax);
    draw_set_alpha(1);
    
    draw_rectangle(rectxmin,rectymin,rectxmax,rectymax,1);
    
    if (objmoving == 1) or (objmoving == 3) or (objmoving == 4)
        {
        xp1 = rectxmin+anixtrans/$ffff*512;
        yp1 = rectymin+aniytrans/$ffff*512;
        xp2 = rectxmax+anixtrans/$ffff*512;
        yp2 = rectymax+aniytrans/$ffff*512;
        xp3 = rectxmax+anixtrans/$ffff*512;
        yp3 = rectymin+aniytrans/$ffff*512;
        xp4 = rectxmin+anixtrans/$ffff*512;
        yp4 = rectymax+aniytrans/$ffff*512;
        rot_r = degtorad(anirot);
        
        angle1 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1));
        dist1 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1);
        
        xpnew1 = anchorx/$ffff*512+cos(rot_r-angle1)*dist1*scalex;
        ypnew1 = anchory/$ffff*512+sin(rot_r-angle1)*dist1*scaley;
        
        angle2 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2));
        dist2 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2);
        
        xpnew2 = anchorx/$ffff*512+cos(rot_r-angle2)*dist2*scalex;
        ypnew2 = anchory/$ffff*512+sin(rot_r-angle2)*dist2*scaley;

        angle3 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3));
        dist3 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3);
        
        xpnew3 = anchorx/$ffff*512+cos(rot_r-angle3)*dist3*scalex;
        ypnew3 = anchory/$ffff*512+sin(rot_r-angle3)*dist3*scaley;
        
        angle4 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4));
        dist4 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4);
        
        xpnew4 = anchorx/$ffff*512+cos(rot_r-angle4)*dist4*scalex;
        ypnew4 = anchory/$ffff*512+sin(rot_r-angle4)*dist4*scaley;
        

        draw_set_color(c_teal);
        draw_rectangle(xp1,yp1,xp2,yp2,1);
        
        draw_line(xpnew1,ypnew1,xpnew3,ypnew3);
        draw_line(xpnew2,ypnew2,xpnew3,ypnew3);
        draw_line(xpnew2,ypnew2,xpnew4,ypnew4);
        draw_line(xpnew4,ypnew4,xpnew1,ypnew1);
    
        draw_set_alpha(0.6);
            //draw_arrow(mean(rectxmin,rectxmax),mean(rectymin,rectymax),mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),12);
            //draw_arrow(mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),mean(xpnew1,xpnew2)+sin(rot_r)*48,mean(ypnew1,ypnew2)-cos(rot_r)*48,9);
        draw_set_alpha(1);
        }
    
    }

draw_set_color(c_gray);

if (placing_status) or (placing == "text")
    draw_preview_element();
    
draw_set_alpha(0.8);
draw_set_font(fnt_tooltip);
draw_set_color(c_ltgray);
draw_text(12,495,"Frame: "+string(frame+1)+"/"+string(maxframes));
draw_text(440,495,"Points: "+string(framepoints));
if (!anienable) and (maxframes &lt; 2)
    draw_set_color(c_dkgray);
else draw_set_color(c_ltgray);
if (scope_start == 0) and (scope_end == maxframes-1)
    draw_text(220,495,"Scope: All frames");
else
    draw_text(220,495,"Scope: "+string(scope_start+1)+" - "+string(scope_end+1));
    
/*draw_set_alpha(0.5);
draw_set_color(c_gray);
draw_line(12,508,512-12,508);
draw_line(12,509,512-12,509);
draw_set_color(c_teal);
draw_line(lerp(12,512-12,scope_start/(maxframes-1)),508,lerp(12,512-12,scope_end/(maxframes-1)),508);
draw_line(lerp(12,512-12,scope_start/(maxframes-1)),509,lerp(12,512-12,scope_end/(maxframes-1)),509);
draw_set_color(c_yellow);
draw_line(lerp(12,512-12,frame/(maxframes-1)),511,lerp(12,512-12,frame/(maxframes-1)),505);
draw_line(lerp(12,512-12,frame/(maxframes-1))+1,511,lerp(12,512-12,frame/(maxframes-1))+1,505);*/


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="48">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
frame = 0;
framehr = 0;
frame_surf_refresh = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (placing == "curve") and (placing_status == 2)
    create_element();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

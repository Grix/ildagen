<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>version = "1.4.1";
versiondate = "2016-09-23";

if (debug_mode)
{
    show_debug_overlay(1);
    gml_release_mode(false);
}
else
{
    gml_release_mode(true);
}

//setup file handling system
FStemp = game_save_id+"temp\";
if (directory_exists("temp"))
{
    while (1)
    {
        file = file_find_first("temp\*", 0);
        show_debug_message(file)
        if (file == "") or is_undefined(file) or !is_string(file)
            break;
        if (!file_delete("temp\"+file))
            break;
    }
}
else
    directory_create("temp");

//declarations and setup
math_set_epsilon(0.00001);
ds_set_precision(0.00001); 
draw_set_circle_precision(24);

varmap = ds_map_create();
parser_shape = ML_InitParserScience(varmap);
    ML_AddVariable(parser_shape, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "max",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_shape, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
varmap = ds_map_create();
parser_cb = ML_InitParserScience(varmap);
    ML_AddVariable(parser_cb, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchorx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchory",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "x",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "y",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "max",255, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_cb, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    
alarm[3] = 120;

el_list = ds_list_create();
undo_list = ds_list_create();
frame_surf = surface_create(512,512);
frame3d_surf = surface_create(512,512);
frame_list = ds_list_create();
ds_list_add(frame_list,el_list);
free_list = ds_list_create();
bez_list = ds_list_create();
font_list = ds_list_create();
snap_list = ds_list_create();
selsurf = surface_create(512,512);
miniaudio_surf = surface_create(512,512);
hershey_preview_surf = -1;
copy_list = -1;
semaster_list = ds_list_create();
hershey_index_list = ds_list_create();
hershey_list = -1;
menu_surf = -1;
dac_list = ds_list_create();
output_buffer = buffer_create(48000,buffer_fixed,2);
output_buffer2 = buffer_create(48000,buffer_fixed,2);
blindzone_list = ds_list_create();

c_gold = make_colour_rgb(255,220,0);

output_buffer_ready = false;
output_buffer_next_size = 0;
dac = -1;
dac_string = "[None]";
laseron = false;
laseronfirst = false;
el_id = 0;
projectfps = 30;
xdelta[32] = 0;
playing = 0;
update_verbose = 0;
updatereceived = 0;
serial = "";
frame_surf_refresh = 0;
refresh_miniaudio_flag = 1;
letter = "";
image_speed = 0;
font_type = -1;
hershey_moving = 0;
hershey_scrollw = 19;
hershey_scrollx = 0;
hershey_scrollh = 4930;
hershey_selected = 0;
dialog_open = false;
regflag = false;
menu_open = 0;
updateget = -1;
updatenotes = -1;
file = -1;
show_ad = true;
show_tooltip = true;

redraw = 0;
sgridshow = 0;
rgridshow = 0;
sgriddouble = 0;
rgriddouble = 0;
guidelineshow = 0;
guidelinedouble = 0;
sgridnum = 16;

mouse_yprevious = mouse_y;
mouse_xprevious = mouse_x;

phi = 1.618;
tlw = 512;
tlh = 42;

tooltip = "";
bckimage = 0;
onion = 0;
onion_dropoff = 0.7;
onion_number = 2;
onion_alpha = 0.8;
scroll = 0;
viewmode = 0;
selectedelement = -1;
selectedelementlist = 0;
exp_optimize = 1;
exp_format = 5;
opt_warning_flag = 0;
getint = -1;
getstr = -1;
dialog = "";
selecting = 0;
scroll = 0;
scrollcursor_flag = 0;

global.loading_exportproject = 0;
global.loading_exportilda = 0;
global.loading_exportildahtml5 = 0;
global.loading_saveproject = 0;
global.loading_loadproject = 0;
global.loading_importilda = 0;
global.loading_importfont = 0;
global.loading_importildaseq = 0;

opt_maxdist = 1500;
opt_maxdwell = 5;
opt_maxdwell_blank = 1;
opt_blankshift = 0;
opt_redshift = 0;
opt_greenshift = 0;
opt_blueshift = 0;
opt_scanspeed = 30000;
invert_y = false;
invert_x = false;
projector = 0;
projector_name = "default";
red_scale = 1;
blue_scale = 1;
green_scale = 1;
red_scale_lower = 0;
blue_scale_lower = 0;
green_scale_lower = 0;
angle_prev = 0;
x_scale_start = 0;
x_scale_end = $FFFF;
y_scale_start = 0;
y_scale_end = $FFFF;

placing = "line";
placing_select_last = "line";
object_select_hovering = 0;
startpos[1] = 0;
placing_status = 0;
wave_amp = 10000;
wave_period = 1;
pointx[20] = 0;
pointy[20] = 0;
wave_offset = 0;
bez_moving = 0;
font_size = 20;

resolution = "auto";
framepoints = 0;
frame_complexity = 0;

reap_color = 1;
reap_blank = 1;
reap_removeoverlap = 0;
reap_trans = 1;
reap_interpolate = 1;
rectxmax = 0;
rectxmin = 0;
rectymax = 0;
rectymin = 0;

colormode = "solid";
colormode2 = 0;
color1 = c_white;
color2 = c_white;
enddotscolor = c_red;
color_period = 8192;
color_freq = 1;
color_dc = 0.5;
color_offset = 0;
color_blendmode = 0; //0 replace, 1 add, 2 subtract

blankmode = "solid";
blankmode2 = 0;
blank_period = 8192;
blank_dc = 0.5;
blank_freq = 4;
blank = 0;
enddots = 0;
makedot = 0;
dotmultiply = 12;
blank_offset = 0;
blank_blendmode = 1; //0 replace, 1 and, 2 or, 3 xor

anienable = 0;
frame = 0;
framehr = 0;
frameprev = 0;
fillframes = 1;
maxframes = 1;
anicolor1 = c_white;
anicolor2 = c_white;
anienddotscolor = c_red;
anicolor_dc = 0.5;
aniblank_dc = 0.5;
aniblank_offset = 0;
anicolor_offset = 0;
aniwave_offset = 0;
anifunc = "saw";
aniwave_amp = 10000;
anirep = 1;

rot = 0;
anirot = 0;
scalex = 1;
scaley = 1;
aniscalex = 1;
aniscaley = 1;
anchorx = $8000;
anchory = $8000;
anixtrans = 0;
aniytrans = 0;
shaking = 0;
shaking_sdev = 5;
anishaking_sdev = 5;
scope_start = 0;
scope_end = 0;
objmoving = 0;
projectfps = 30;

shapefunc_cp = 100;
shapefunc_string_x = "";
shapefunc_string_y = "";
colorfunc_string_1 = "";
colorfunc_string_2 = "";
colorfunc_string_3 = "";
blankfunc_string = "";

draw_set_font(fnt_tooltip);
menu_string = "   File      Properties      Edit      Tools      View      Settings      About   ";
menu_width_start[0] = 0;
menu_width[0] = string_width("   File   ");
menu_width_start[1] = menu_width[0];
menu_width[1] = string_width("   Properties   ");
menu_width_start[2] = menu_width_start[1]+menu_width[1];
menu_width[2] = string_width("   Edit   ");
menu_width_start[3] = menu_width_start[2]+menu_width[2];
menu_width[3] = string_width("   Tools   ");
menu_width_start[4] = menu_width_start[3]+menu_width[3];
menu_width[4] = string_width("   View   ");
menu_width_start[5] = menu_width_start[4]+menu_width[4];
menu_width[5] = string_width("   Settings   ");
menu_width_start[6] = menu_width_start[5]+menu_width[5];
menu_width[6] = string_width("   About   ");
menu_width_start[7] = menu_width_start[6]+menu_width[6];

radialgrid_surf = surface_create(512,512);
surface_set_target(radialgrid_surf);
    draw_radialgrid();
surface_reset_target();
squaregrid_surf = surface_create(512,512);
surface_set_target(squaregrid_surf);
    draw_grid();
surface_reset_target();

init_palette();

if (os_browser == browser_not_a_browser)
{
    update_check();
    parse_parameter();
    load_settings();
}

verify_serial(1);
telem();
    
instance_create(floor((view_wview[0]-700)/2), floor((view_hview[0]-420)/2), obj_ad);

ex_patch_window_close_capture(1);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset menu_open

menu_open = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
guidelinedouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game end

game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean undo

alarm[3] = 1200;

while (ds_list_size(undo_list) &gt; 100)
    {
    show_debug_message("cleaning undo list");
    undo = ds_list_find_value(undo_list,0);
    ds_list_delete(undo_list,0);

    if (is_real(undo))
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'a')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'r')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'd')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'v')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'b')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'k')
        {
        //undo reapply elements
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            if (ds_exists(list,ds_type_list))
                ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    else if (string_char_at(undo,0) == 'l')
        {
        //undo delete
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            if (ds_exists(list,ds_type_list))
                ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
sgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
rgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
scroll = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ex_patch_window_close_event())
    exit_confirm();
    
if (keyboard_check_pressed(ord('M')))
{
    window_set_fullscreen(0);
    window_set_size(room_width,room_height);
}
else if (keyboard_check_released(vk_f11))
    window_set_fullscreen(!window_get_fullscreen());
    
if (room == rm_loading)
{
    if (global.loading_exportilda == 1)
        export_ilda_work();
    else if (global.loading_exportildahtml5 == 1)
        export_ilda_html5_work();
    else if (global.loading_importilda == 1)
    {
        if (global.loading_current &lt; global.loading_end)
            read_ilda_work();
        else
            import_ilda_end();
    }
    else if (global.loading_importfont == 1)
    {
        if (global.loading_current &lt; global.loading_end)
            read_ilda_work();
        else
            import_font_end();
    }
}
    
with (obj_cursor)
{
    if (room == rm_ilda) and (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
    {
        image_index = 8;
        x = clamp(mouse_x,0,view_wview[0]-128);
        y = clamp(mouse_y,0,view_hview[0]-128);
    }
    else
    {
        x = mouse_x;
        y = mouse_y;
    }
}

if (room != rm_ilda) exit;

el_list = frame_list[| frame];

if (placing = "hershey")
    hershey_handle_scroll();
    
object_select_hovering = 0;

if (keyboard_check_pressed(vk_space))
{
    playing = !playing;
    if (seqcontrol.song)
    {
        if (playing)
        {
            FMODInstanceSetPosition(seqcontrol.songinstance,(tlx+framehr)/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
            FMODInstanceSetPaused(seqcontrol.songinstance,0);
        }
        else
            FMODInstanceSetPaused(seqcontrol.songinstance,1);
    }
}
    
else if (keyboard_check_pressed(vk_backspace))
{
    deselect_object();
}
    
else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('Z')))
{
    undo_ilda();
}
        
else if (keyboard_check_pressed(ord("0")))
{
    ilda_cancel();
    frame = 0;
    framehr = 0;
}
    
else if (keyboard_check_pressed(ord("P")))
{
    viewmode++;
    if (viewmode &gt; 2)
        viewmode = 0;
    frame_surf_refresh = 1;
}
else if (keyboard_check_pressed(vk_escape))
{
    ds_list_clear(semaster_list);
        
    if (laseron)
    {
        laseron = false;
        frame_surf_refresh = true;
        dac_blank_and_center(dac);
    }
}
    
else if (keyboard_check(vk_control) or (placing == "select")) and ds_list_size(el_list)
{
    check_elementselect();
}
    
//PASTE
if (keyboard_check(vk_control) and keyboard_check_pressed(ord('V')))
{
    paste_object();
}
    
if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
{
    view_visible[2] = 1;
    view_xport[2] = clamp(obj_cursor.x-128,0,view_wview[0]-256);
    view_yport[2] = clamp(obj_cursor.y-128,0,view_hview[0]-256);
}
else
    view_visible[2] = 0;
    
if (keyboard_check(ord('S'))) or (sgridshow == 1)
{
    with (obj_cursor)
    {
        if (x &lt; 512) and (y &lt; 512)
            move_snap(512/controller.sgridnum,512/controller.sgridnum);
    }
}

if (ds_list_size(el_list) &gt; 0)
{
    if (keyboard_check(vk_alt) and (placing_status == 0))
    {
        if (keyboard_check(vk_control))
        {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),0)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),1)/128;
        }
        else
        {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),2)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),3)/128;
        }
    }
    else if (keyboard_check(ord('Q')))
    {
        nearestdist = 32;
        for (i = 0;i &lt; ds_list_size(el_list);i++)
        {
            templist =  ds_list_find_value(el_list,i);
            if (point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y) &lt; nearestdist)
            {
                obj_cursor.x = ds_list_find_value(templist,0)/128;
                obj_cursor.y = ds_list_find_value(templist,1)/128;
                nearestdist = point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y);
            }
            if (point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y) &lt; nearestdist)
            {
                obj_cursor.x = ds_list_find_value(templist,2)/128;
                obj_cursor.y = ds_list_find_value(templist,3)/128;
                nearestdist = point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y);
            }
        }
        
    }
}
    
if (!surface_exists(frame_surf) || (!surface_exists(frame3d_surf) &amp;&amp; viewmode != 0))
    frame_surf_refresh = true;

    
//SELECTED ELEMENT STUFFS
canrightclick = 1;
if !ds_list_empty(semaster_list)
{
    canrightclick = !handle_trans();
    
    //COPY
    if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('C')))
    {
        copy_object();
    }
        
    //CUT
    else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('X')))
    {
        cut_object();
    }
        
    //DELETE
    else if (keyboard_check_pressed(vk_delete))
    {
        delete_object();
    }
}

if (mouse_x == clamp(mouse_x,0,512)) and (mouse_y == clamp(mouse_y,0,512))
and (mouse_check_button_pressed(mb_right)) and (canrightclick)
    dropdown_empty();
    
//KEYBOARD RIGHT LEFT
if (keyboard_check(vk_left)) and (maxframes &gt; 1) and (placing_status == 0)
{
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_left))
    {
        frame--;
        framehr--;
        scroll = 0;
        alarm[0] = 30;
    }
    else if (scroll)
        framehr -= delta_time/1000000*seqcontrol.projectfps;
    if (framehr &lt; -0.5)
        framehr+= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
    }
}
else if (keyboard_check(vk_right)) and (maxframes &gt; 1) and (placing_status == 0)
{
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_right))
    {
        frame++;
        framehr++;
        scroll = 0;
        alarm[0] = 30;
    }
    else if (scroll)
        framehr += delta_time/1000000*seqcontrol.projectfps;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
        frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
    }
}
    
if (frame &gt;= maxframes)
{
    frame = maxframes-1;
    framehr = maxframes-1;
}
    
frameprev = frame;    

//guidelines
if (keyboard_check(ord('A')) or (guidelineshow == 1))
{
    if  (keyboard_check_pressed(ord('A')))
    {
        if (guidelinedouble == 1)
            guidelineshow = !guidelineshow;
        alarm[5] = 30;
        guidelinedouble = 1;
    }
}
   
//grids 
if (keyboard_check(ord('S')) or (sgridshow == 1))
{
    if  (keyboard_check_pressed(ord('S')))
    {
        if (sgriddouble == 1)
            sgridshow = !sgridshow;
        alarm[2] = 30;
        sgriddouble = 1;
    }
    if (keyboard_check_pressed(vk_up))
    {
        controller.sgridnum -= 1;
        if (controller.sgridnum &lt; 1)
            controller.sgridnum = 1;
        square_grid_refresh();
    }
    if (keyboard_check_pressed(vk_down))
    {
        controller.sgridnum += 1;
        square_grid_refresh();
    }
} 
if (keyboard_check(ord('R')) or (rgridshow == 1))
{
    if  (keyboard_check_pressed(ord('R')))
    {
        if (rgriddouble == 1)
            rgridshow = !rgridshow;
        alarm[1] = 30;
        rgriddouble = 1;
    }
}

if (keyboard_check_pressed(vk_tab))
{
    if (os_browser != browser_not_a_browser)
    {
        show_message_async("Sorry, the timeline is not available in the web version yet");
        exit;
    }
    ilda_cancel();
    frame = 0;
    framehr = 0;
    if (seqcontrol.song)
        FMODInstanceSetPaused(seqcontrol.songinstance,1);
        
    room_goto(rm_seq);
}
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///timing and laser output
if (room != rm_ilda) exit;

if (playing == 1)
{
    if (maxframes &lt;= 1)
    {
        playing = 0;
        if (seqcontrol.song)
            FMODInstanceSetPaused(seqcontrol.songinstance,1);
    }
        
    framehr += delta_time/1000000*seqcontrol.projectfps*seqcontrol.playbackspeed;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = clamp(round(framehr),0,maxframes-1);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
    {
        frame_surf_refresh = 1;
    }
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
    }
        
    if (frameprev != 0) and (frame == 0) and (seqcontrol.song)
    {
        FMODInstanceSetPosition(seqcontrol.songinstance,tlx/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
    }
        
    var t_minroomspeed = max(projectfps,25);
}
else
{
    var t_minroomspeed = 60;
}

room_speed = projectfps;
while (room_speed &lt; t_minroomspeed)
    room_speed += projectfps;

if (laseron)
{
    if (!ds_exists(dac,ds_type_list))
    {
        show_message_async("Error, DAC data missing");
        laseron = false;
        dac = -1;
        dac_string = "[None]";
    }
    else
        output_frame();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (instance_exists(oDropDown))
    exit;

if ((mouse_x &gt; 550) or (mouse_y &gt; 550)) and (placing_status != 2) or (!ds_list_empty(semaster_list) and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
))
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }

if (placing_status == 1) and (placing != "text") and (placing != "select")
    {
    if (placing != "curve")
        create_element();
    else
        {
        placing_status = 2;
        point1x = startpos[0]+cos(-mousedir-pi/2)*100;
        if (point1x &gt; 500) or (point1x &lt; 10)
            point1x = startpos[0]+cos(-mousedir+pi/2)*100;
        point1y = startpos[1]+sin(-mousedir-pi/2)*100;
        if (point1y &gt; 500) or (point1y &lt; 10)
            point1y = startpos[1]+sin(-mousedir+pi/2)*100;
        point2x = endx+cos(-mousedir-pi/2)*100;
        if (point2x &gt; 500) or (point2x &lt; 10)
            point2x = endx+cos(-mousedir+pi/2)*100;
        point2y = endy+sin(-mousedir-pi/2)*100;
        if (point2y &gt; 500) or (point2y &lt; 10)
            point2y = endy+sin(-mousedir+pi/2)*100;
        ds_list_replace(bez_list,2,point1x);
        ds_list_replace(bez_list,3,point1y);
        ds_list_replace(bez_list,4,point2x);
        ds_list_replace(bez_list,5,point2y);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    }
    
bez_moving = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
    
//menu
if (mouse_y &gt; view_yview[3])   
    {
    if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
        dropdown_menu_ilda_file();
        }
    else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
        dropdown_menu_ilda_properties();
        }
    else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
        dropdown_menu_ilda_edit();
        }
    else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
        dropdown_menu_ilda_tools();
        }
    else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
        dropdown_menu_ilda_view();
        }
    else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
        dropdown_menu_ilda_settings();
        }
    else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
        dropdown_menu_ilda_about();
        }
    exit;
    }

if (instance_exists(oDropDown)) or (mouse_x &gt; 512) or (mouse_y &gt; 512) or (keyboard_check(vk_control) or (placing == "select"))
    exit;

if !ds_list_empty(semaster_list)  and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
)
    exit;
    
ds_list_clear(semaster_list);

if ((keyboard_check(ord('E'))) and (placing_status != 2))
    {
    ds_list_add(undo_list,"bb"+string(color2));
    ds_list_add(undo_list,"b"+string(color1));
    color1 = draw_getpixel(obj_cursor.x,obj_cursor.y+23);
    update_colors();
    exit;
    }

if ((mouse_x &gt; 515) or (mouse_y &gt; 515)) and (placing_status != 2)
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }
    
    
if (placing_status == 0)
    {
    placing_status = 1;
    startpos[0] = obj_cursor.x;
    startpos[1] = obj_cursor.y;
    if (placing == "text")
        create_text_init();
    else if (placing == "free")
        {
        ds_list_add(free_list,0);
        ds_list_add(free_list,0);
        }
    else if (placing == "curve")
        {
        bezier_coeffs(0,0,0,0,0,0,0,0);
        ds_list_add(bez_list,startpos[0]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        }
    }
    
else if (placing_status == 2) and (placing == "curve")
    {
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3)) &lt; 7)
        bez_moving = 1;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5)) &lt; 7)
        bez_moving = 2;
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1)) &lt; 7)
        bez_moving = 3;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7)) &lt; 7)
        bez_moving = 4;
    mouse_yprevious = mouse_y;
    mouse_xprevious = mouse_x;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (mouse_x &gt; 512) or (mouse_y &gt; 512)
    exit;
if (instance_exists(oDropDown))
    exit;

    
if (placing == "free")
    {
    if (placing_status == 1)
        {
        autoresflag = 0;
        if (is_string(resolution)) 
            {
            autoresflag = 1; 
            resolution = 512;
            }
        if (point_distance(startpos[0]+ds_list_find_value(free_list,ds_list_size(free_list)-2),startpos[1]+ds_list_find_value(free_list,ds_list_size(free_list)-1),mouse_x,mouse_y) &gt;= resolution/128)
            {
            ds_list_add(free_list,mouse_x-startpos[0]);
            ds_list_add(free_list,mouse_y-startpos[1]);
            }
        if (autoresflag)
            resolution = "auto";
        }
    }
else if (placing == "curve")
    {
    if (placing_status == 1)
        {
        mousedir = degtorad(point_direction(startpos[0],startpos[1],endx,endy));
        ds_list_replace(bez_list,6,endx);
        ds_list_replace(bez_list,7,endy);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    else if (placing_status == 2)
        {
        if (bez_moving == 1)
            {
            ds_list_replace(bez_list,2,ds_list_find_value(bez_list,2)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,3,ds_list_find_value(bez_list,3)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 2)
            {
            ds_list_replace(bez_list,4,ds_list_find_value(bez_list,4)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,5,ds_list_find_value(bez_list,5)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 3)
            {
            ds_list_replace(bez_list,0,ds_list_find_value(bez_list,0)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,1,ds_list_find_value(bez_list,1)+mouse_y-mouse_yprevious);
            startpos[0] = ds_list_find_value(bez_list,0);
            startpos[1] = ds_list_find_value(bez_list,1);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 4)
            {
            ds_list_replace(bez_list,6,ds_list_find_value(bez_list,6)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,7,ds_list_find_value(bez_list,7)+mouse_y-mouse_yprevious);
            endx = ds_list_find_value(bez_list,6);
            endy = ds_list_find_value(bez_list,7);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        }
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//what a mess

dialog_open = 0;

//Get integer
new_id = ds_map_find_value(async_load, "id");
if (new_id == getint)
    {
    /*if (dialog == "update")
        {
        updatecheckenabled = ds_map_find_value(async_load, "status");
        ini_filename = "settings.ini";
        ini_open(ini_filename);
        ini_write_real("main","updatecheck",updatecheckenabled);
        ini_close();
        if (updatecheckenabled)
            {
            updateget = http_get("http://github.com/Grix/ildagen/raw/master/version.txt");
            }
        }  */

    if ds_map_find_value(async_load, "status")
        {
        switch (dialog)
            {
            case "exit":
                {
                game_end();
                break;
                }
            case "preset_delete":
                {
                ini_open("settings.ini");
                
                var t_currentprojectorstring = "projector_"+string(projector);
                var t_proj_i = projector;
                while (ini_section_exists("projector_"+string(t_proj_i)))
                    {
                    t_proj_i++;
                    }
                t_proj_i--;
                    
                if (t_proj_i == projector)
                    {
                    if (t_proj_i == 0)
                        {
                        ini_section_delete(t_currentprojectorstring);
                        ini_key_delete("main","projector");
                        }
                    else
                        {
                        ini_section_delete("projector_"+string(projector));
                        ini_write_real("main","projector",projector-1);
                        }
                    }
                else
                    {
                    var t_projectorstring = "projector_"+string(t_proj_i);
                    ini_write_string(t_currentprojectorstring, "name", ini_read_string(t_projectorstring,"name","error_name"));
                    ini_write_real(t_currentprojectorstring, "scanrate", ini_read_real(t_projectorstring,"scanrate",20000));
                    ini_write_real(t_currentprojectorstring, "maxdwell", ini_read_real(t_projectorstring,"maxdwell",4));
                    ini_write_real(t_currentprojectorstring, "maxdist", ini_read_real(t_projectorstring,"maxdist",1500));
                    ini_write_real(t_currentprojectorstring, "format", ini_read_real(t_projectorstring,"format",5));
                    ini_write_real(t_currentprojectorstring, "optimize", ini_read_real(t_projectorstring,"optimize",1));
                    ini_write_real(t_currentprojectorstring, "blankshift", ini_read_real(t_projectorstring,"opt_blankshift",0));
                    ini_write_real(t_currentprojectorstring, "redshift", ini_read_real(t_projectorstring,"opt_redshift",0));
                    ini_write_real(t_currentprojectorstring, "greenshift", ini_read_real(t_projectorstring,"opt_greenshift",0));
                    ini_write_real(t_currentprojectorstring, "blueshift", ini_read_real(t_projectorstring,"opt_blueshift",0));
                    ini_write_real(t_currentprojectorstring, "invert_y", ini_read_real(t_projectorstring,"invert_y",false));
                    ini_write_real(t_currentprojectorstring, "invert_x", ini_read_real(t_projectorstring,"invert_x",false));
                    ini_write_real(t_currentprojectorstring, "red_scale", ini_read_real(t_projectorstring,"red_scale",1));
                    ini_write_real(t_currentprojectorstring, "green_scale", ini_read_real(t_projectorstring,"green_scale",1));
                    ini_write_real(t_currentprojectorstring, "blue_scale", ini_read_real(t_projectorstring,"blue_scale",1));
                    ini_write_real(t_currentprojectorstring, "red_scale_lower", ini_read_real(t_projectorstring,"red_scale_lower",0));
                    ini_write_real(t_currentprojectorstring, "green_scale_lower", ini_read_real(t_projectorstring,"green_scale_lower",0));
                    ini_write_real(t_currentprojectorstring, "blue_scale_lower", ini_read_real(t_projectorstring,"blue_scale_lower",0));
                    ini_write_real(t_currentprojectorstring, "show_tooltip", ini_read_real(t_projectorstring,"show_tooltip",1));
                    ini_section_delete(t_projectorstring);
                    ini_write_real("main","projector",projector);
                    }
                ini_close(); 
                   
                load_settings();
                
                break;
                }
            
            case "toseqreplace":
                {
                frames_toseq();
                
                break;
                }
          
            case "updatefound":
                {
                file = http_get_file("https://github.com/Grix/ildagen/raw/master/LasershowGen-"+versionnew+"-Installer.exe","temp/update.exe");
                show_message_async("Download started, program will exit and installation start shortly..");
                break;
                }    
            case "maxdist":
              {
              opt_maxdist = ds_map_find_value(async_load, "value");
              save_settings();
              
              break;
              }
            case "blankshift":
              {
              opt_blankshift = ds_map_find_value(async_load, "value");
              save_settings();
              
              break;
              }
            case "maxdwell":
              {
              opt_maxdwell = ds_map_find_value(async_load, "value");
              save_settings();
              
              break;
              }  
            case "maxdwell_blank":
              {
              opt_maxdwell_blank = ds_map_find_value(async_load, "value");
              save_settings();
              
              break;
              }  
            case "scanspeed":
              {
              opt_scanspeed = ds_map_find_value(async_load, "value");
              save_settings();
              
              break;
              }
            case "wavet":
              {
              wave_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "waveamp":
              {
              wave_amp = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "waveoffset":
              {
              wave_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "shapefuncpoints":
              {
              shapefunc_cp = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "colorfreq":
              {
              color_freq = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "colordc":
              {
              color_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "colorperiod":
              {
              color_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "coloroffset":
              {
              color_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankoffset":
              {
              blank_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankdc":
              {
              blank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "aniblankdc":
              {
              aniblank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "blankperiod":
              {
              blank_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankfreq":
              {
              blank_freq = ds_map_find_value(async_load, "value");
              
              break;
              }
              
            //ANI
            case "aniblankoffset":
              {
              aniblank_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "anicolordc":
              {
              anicolor_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "anicoloroffset":
              {
              anicolor_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "aniwaveoffset":
              {
              aniwave_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "aniwaveamp":
              {
              aniwave_amp = ds_map_find_value(async_load, "value");
              
              break;
              }
              
              //COLOR
            case "c1r":
              {
              color1 = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color1),colour_get_blue(color1));
              break;
              }
            case "c1g":
              {
              color1 = make_colour_rgb(colour_get_red(color1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color1));
              
              break;
              }
            case "c1b":
              {
              color1 = make_colour_rgb(colour_get_red(color1),colour_get_green(color1),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "c2r":
              {
              color2 = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color2),colour_get_blue(color2));
              
              break;
              }
            case "c2g":
              {
              color2 = make_colour_rgb(colour_get_red(color2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color2));
              
              break;
              }
            case "c2b":
              {
              color2 = make_colour_rgb(colour_get_red(color2),colour_get_green(color2),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "red_scale":
              {
              red_scale = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "green_scale":
              {
              green_scale = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "blue_scale":
              {
              blue_scale = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "red_scale_lower":
              {
              red_scale_lower = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "green_scale_lower":
              {
              green_scale_lower = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "blue_scale_lower":
              {
              blue_scale_lower = clamp(ds_map_find_value(async_load, "value")/100,0,1);
              update_colors_scalesettings();
              save_settings();
              break;
              }
            case "anirep":
              {
              anirep = ds_map_find_value(async_load, "value");
              break;
              }
            case "c3r":
              {
              enddotscolor = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(enddotscolor),colour_get_blue(enddotscolor));
              
              break;
              }
            case "c3g":
              {
              enddotscolor = make_colour_rgb(colour_get_red(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(enddotscolor));
              
              break;
              }
            case "c3b":
              {
              enddotscolor = make_colour_rgb(colour_get_red(enddotscolor),colour_get_green(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
              //ANI COLOR
            case "ac1r":
              {
              anicolor1 = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor1),colour_get_blue(anicolor1));
              
              break;
              }
            case "ac1g":
              {
              anicolor1 = make_colour_rgb(colour_get_red(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor1));
              
              break;
              }
            case "ac1b":
              {
              anicolor1 = make_colour_rgb(colour_get_red(anicolor1),colour_get_green(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "ac2r":
              {
              anicolor2 = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor2),colour_get_blue(anicolor2));
              
              break;
              }
            case "ac2g":
              {
              anicolor2 = make_colour_rgb(colour_get_red(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor2));
              
              break;
              }
            case "ac2b":
              {
              anicolor2 = make_colour_rgb(colour_get_red(anicolor2),colour_get_green(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "ac3r":
              {
              anienddotscolor = make_colour_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anienddotscolor),colour_get_blue(anienddotscolor));
              
              break;
              }
            case "ac3g":
              {
              anienddotscolor = make_colour_rgb(colour_get_red(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anienddotscolor));
              
              break;
              }
            case "ac3b":
              {
              anienddotscolor = make_colour_rgb(colour_get_red(anienddotscolor),colour_get_green(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
              
            case "aniscale":
              {
              scalex = ds_map_find_value(async_load, "value");
              scaley = scalex;
              reapply_trans();
              
              
              break;
              }            
              
            case "anirot":
              {
              anirot = ds_map_find_value(async_load, "value");
              reapply_trans();
              
              
              break;
              }
            
            case "clearall":
              {
              clear_all();
              
              break;
              }
              
            case "loadfile":
              {
              load_frames(get_open_filename_ext("LasershowGen frames|*.igf","","","Select LasershowGen frames file"));
              
              break;
              }
            
            case "dotintensity":
              {
              ds_list_add(undo_list,"d"+string(dotmultiply))
            
              dotmultiply = ds_map_find_value(async_load, "value");
              dotmultiply = clamp(dotmultiply,1,500);
              
              break;
              }
            case "onion_number":
              {
              onion_number = ds_map_find_value(async_load, "value");
              frame_surf_refresh = 1;
              
              break;
              }
            case "onion_alpha":
              {
              onion_alpha = clamp(ds_map_find_value(async_load, "value"),0,1);
              frame_surf_refresh = 1;
              
              break;
              }
            case "onion_dropoff":
              {
              onion_dropoff = clamp(ds_map_find_value(async_load, "value"),0,1);
              frame_surf_refresh = 1;
              
              break;
              }
            case "fontsize":
              {
              font_size = clamp(ds_map_find_value(async_load, "value"),1,128);
              break;
              }
              
            case "res":
              {
              ds_list_add(undo_list,"r"+string(resolution))
            
              resolution = ds_map_find_value(async_load, "value");
              if (resolution &lt; 4) resolution = 4;
              if (resolution &gt; $8000) resolution = $8000;
              
              break;
              }
              
            case "scopestart":
              {
              scope_start = clamp(ds_map_find_value(async_load, "value")-1,0,scope_end-1);
              frame = scope_start;
              framehr = scope_start;
              frame_surf_refresh = 1;
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "scopeend":
              {
              scope_end = clamp(ds_map_find_value(async_load, "value")-1,scope_start+1,maxframes-1);
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "fps":
              {
              seqcontrol.projectfps = clamp(ds_map_find_value(async_load, "value"),1,999);
              projectfps = seqcontrol.projectfps;
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "shaking_sdevset":
              {
              shaking_sdev = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "anishaking_sdevset":
              {
              anishaking_sdev = ds_map_find_value(async_load, "value");
              
              break;
              }
              
            case "maxframes":
              {
              ds_list_add(undo_list,"a"+string(maxframes))
              
              refresh_miniaudio_flag = 1;
              
              scopeflag = 0;
              if (maxframes == (scope_end+1)) scopeflag = 1;
              
              maxframes = ds_map_find_value(async_load, "value");
              
              if (maxframes &lt; 1) maxframes = 1;
              else if (maxframes &gt; $ffff) maxframes = $ffff;
              
              if (ds_list_size(frame_list) &lt; maxframes)
                  repeat (maxframes - ds_list_size(frame_list))
                      {
                      templist = ds_list_create();
                      if (fillframes)
                          {
                          tempelcount = ds_list_size(ds_list_find_value(frame_list,ds_list_size(frame_list)-1));
                          for (u = 0;u &lt; tempelcount;u++)
                              {
                              tempellist = ds_list_create();
                              ds_list_copy(tempellist,ds_list_find_value(ds_list_find_value(frame_list,ds_list_size(frame_list)-1),u));
                              ds_list_add(templist,tempellist);
                              }
                          }
                      ds_list_add(frame_list,templist);
                      }
              /*else
                  repeat (ds_list_size(frame_list)-maxframes)
                      {
                      el_list_temp = ds_list_find_value(frame_list,ds_list_size(frame_list)-1);
                      //for (u = 0;u &lt; ds_list_size(el_list_temp);u++)
                      //    ds_list_destroy(ds_list_find_value(el_list_temp,u));
                      ds_list_destroy(el_list_temp);
                      }*/
              if (frame &gt; maxframes) 
                  {
                  frame = maxframes-1;
                  framehr = maxframes-1;
                  }
                  
              dd_scope_reset();
              
              break;
              }
              
            }
        }
    }
else if (new_id == getstr)
    {
    if ds_map_find_value(async_load, "status")
       {
      if ds_map_find_value(async_load, "result") != ""
          {
          switch (dialog)
            {
            case ("preset_create"):
                {
                ini_open("settings.ini");
                num = 0;
                while (ini_section_exists("projector_"+string(num)))
                    {
                    num++;
                    }
                ini_write_real("main","projector",num);
                projector = num;
                ini_write_string("projector_"+string(num),"name",ds_map_find_value(async_load, "result"));
                ini_close();
                save_settings();
                break;
                }
            case ("preset_rename"):
                {
                ini_open("settings.ini");
                if (ini_section_exists("projector_"+string(projector)))
                    {
                    ini_write_string("projector_"+string(projector),"name",ds_map_find_value(async_load, "result"));
                    }
                ini_close();
                save_settings();
                break;
                }
            case ("funcx"):
                {
                shapefunc_string_x = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcy"):
                {
                shapefunc_string_y = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func1"):
                {
                colorfunc_string_1 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func2"):
                {
                colorfunc_string_2 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func3"):
                {
                colorfunc_string_3 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcen"):
                {
                blankfunc_string = ds_map_find_value(async_load, "result");
                break;
                }
            case ("text"):
                {
                text = ds_map_find_value(async_load, "result");

                for (i = 0;i &lt;= maxframes;i++)
                    xdelta[i] = 0;
                
                //start making elements
                for (texti = 1; texti &lt;= string_length(text);texti++)
                    {
                    letter = string_char_at(text,texti);
                    if (ord(letter) != clamp(ord(letter),33,126))
                        {
                        for (i = 0;i &lt;= maxframes;i++)
                            xdelta[i] += font_size*1.3;
                        }
                    else
                        {
                        create_element();
                        }
                    }
                    
                frame_surf_refresh = 1;
                break;
                }
            case ("exporthtml5"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                export_ilda_html5();
                break;
                }
            case ("saveframes"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                save_frames_html5();
                break;
                }
            case ("serial"):
                {
                serial = ds_map_find_value(async_load, "result");
                controller.serialfile = file_text_open_write("serial");
                file_text_write_string(controller.serialfile,string_lettersdigits(controller.serial));
                file_text_close(controller.serialfile);
                verify_serial();
                break;
                }
            }
          }
      }
    }
    
update_colors();
update_anicolors();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if (!updatecheckenabled)
//    exit;
    
if (ds_map_find_value(async_load, "id") == updateget)
    {
    if ds_map_find_value(async_load, "status") == 0
       {
       versionnew = ds_map_find_value(async_load, "result");
       show_debug_message("Checking version")
       if (versionnew != version)
            {
            ilda_dialog_yesno("updatefound","New version available: "+versionnew+"#"+"Would you like to download and install the update?##"+releasenotes+"##");
            }
       else if (update_verbose == 1)
            {
            show_message_async("Current version is up to date.");
            }
       }
    }
else if (ds_map_find_value(async_load, "id") == updatenotes)
    {
    if ds_map_find_value(async_load, "status") == 0
       {
       releasenotes = ds_map_find_value(async_load, "result");
       updateget = http_get("https://raw.githubusercontent.com/Grix/ildagen/master/version.txt");
       }
    }
else if (ds_map_find_value(async_load, "id") == file)
    {
     if ds_map_find_value(async_load, "status") == 0
        {
        if (file_exists("temp/update.exe"))
            {
            if (alarm[4] == -1)
                {
                show_message_async("Launching installer");
                url_open_new(FStemp+"update.exe")
                alarm[4] = 60;
                }
            }
        else 
            {
            if (updatereceived == 0)
                {
                show_message_async("Failed to automatically download update. Opening download website..");
                url_open_new("http://bitlasers.com/opencart/index.php?route=product/product&amp;path=67&amp;product_id=82");
                updatereceived = 1;
                }
            }
         }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (laseron)
    dac_blank_and_center(dac);

refresh_miniaudio_flag = 1;
frame_surf_refresh = 1;
laseron = false;
menu_open = 0;
dialog_open = 0;
playing = 0;
seqcontrol.frame_surf_refresh = true;
output_buffer_ready = false;

if (room == rm_ilda)
    window_set_caption("LasershowGen - Editor Mode");
else if (room == rm_seq)
    window_set_caption("LasershowGen - Timeline Mode");
else if (room == rm_options)
    window_set_caption("LasershowGen - Settings");
else if (room == rm_loading)
    window_set_caption("LasershowGen - Working...");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>FMODfree();
UnloadFMOD();
close_dacs();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (tooltip != "")
{
    if (show_tooltip)
    {
        draw_set_alpha(0.8);
        draw_set_color(c_black);
        draw_rectangle(0,0,string_width(tooltip)+20,string_height(tooltip)+10,0);
        draw_set_color(c_white);
        draw_set_alpha(1);
        draw_text(5,5,tooltip);
    }
    tooltip = "";
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

if (placing = "hershey")
    {
    draw_background_part(bck_hershey3,0,clamp(hershey_scrollx-4096,0,2048),420,120-clamp(4096-hershey_scrollx,0,120),650,30+clamp(4096-hershey_scrollx,0,120));
    draw_background_part(bck_hershey2,0,clamp(hershey_scrollx-2048,0,2048),420,120-clamp(2048-hershey_scrollx,0,120),650,30+clamp(2048-hershey_scrollx,0,120));
    draw_background_part(bck_hershey1,0,clamp(hershey_scrollx,0,2048),420,120,650,30);
    
    draw_set_alpha(1);
    draw_set_colour(c_white);
    draw_rectangle(1070,30,1090,150,0);
    draw_set_colour(c_black);
    draw_rectangle(1070,30,1090,150,1);
    draw_set_colour(c_dkgray);
    draw_rectangle(1070,30+hershey_scrollx*100/hershey_scrollh,1090,30+hershey_scrollx*100/hershey_scrollh+hershey_scrollw,0);
    
    yo = ceil((hershey_selected+1)/14)*30-30;
    if (yo = clamp(yo,hershey_scrollx-30,hershey_scrollx+120))
        {
        draw_set_alpha(0.3)
        draw_set_colour(c_gold);
        xo = (hershey_selected mod 14)*30;
        draw_rectangle(650+xo,max(30+yo-hershey_scrollx,30),680+xo,min(30+yo-hershey_scrollx+30,150),0);
        }
    }

if (!surface_exists(miniaudio_surf) || refresh_miniaudio_flag)
    {
    refresh_miniaudio_surf();
    refresh_miniaudio_flag = 0;
    }
    
draw_set_color(c_white);
    draw_ilda_2d();
    
draw_set_color(c_white);
draw_set_alpha(1);
if (surface_exists(miniaudio_surf))
    draw_surface_part(miniaudio_surf,0,0,tlw,tlh+1,0,515);
if (maxframes &gt; 1)
    {
    draw_set_color(c_black);
    cursorlinex = lerp(2,510,frame/(maxframes-1))//framehr/projectfps/1000;//framehr/1000*projectfps;
    draw_line(cursorlinex,515,cursorlinex,515+tlh-13);
    }
draw_set_color(c_white);

if (!laseron)
    {
    if (bckimage)
        {
        if (!keyboard_check(ord('E')))
            draw_set_alpha(0.3);
        if (sprite_exists(bck_bckimage))
            {
            draw_sprite_stretched(bck_bckimage,0,bckimage_left,bckimage_top,bckimage_width,bckimage_height);
            }
        else bckimage = 0;
        }
    
    if (object_select_hovering = 1)
        {
        draw_set_alpha(0.5);
        draw_set_colour(c_teal);
            draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
        draw_set_alpha(1);
        draw_set_colour(c_white);
        }
    else if (object_select_hovering = 2)
        {
        draw_set_alpha(0.7);
        draw_set_colour(c_maroon);
            draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
        draw_set_alpha(1);
        draw_set_colour(c_white);
        }
    
    draw_set_color(c_gray);
    if (objmoving == 3)
        draw_text(20,20,string_format(anirot,3,2)+" deg");
    else if (objmoving == 1)
        {
        draw_text(20,20,"X translation: "+string_format(anixtrans,5,0));
        draw_text(20,40,"Y translation: "+string_format(aniytrans,5,0));
        }
    else if (objmoving == 2)
        {
        draw_text(20,20,"Anchor X: "+string_format(anchorx,5,0));
        draw_text(20,40,"Anchor Y: "+string_format(anchory,5,0));
        }
    else if (objmoving == 4)
        {
        draw_text(20,20,"X scale: "+string_format(scalex,2,3));
        draw_text(20,40,"Y scale: "+string_format(scaley,2,3));
        }
    draw_set_color(c_white);
        
    draw_set_alpha(0.7);
       
    //grids 
    if (keyboard_check(ord('S')) or (sgridshow == 1))
        {
        if (!surface_exists(squaregrid_surf))
            {
            squaregrid_surf = surface_create(512,512);
            surface_set_target(squaregrid_surf);
                draw_grid();
            surface_reset_target();
            }
        draw_surface(squaregrid_surf,0,0);
        } 
    if (keyboard_check(ord('R')) or (rgridshow == 1))
        {
        if (!surface_exists(radialgrid_surf))
            {
            radialgrid_surf = surface_create(512,512);
            surface_set_target(radialgrid_surf);
                draw_radialgrid();
            surface_reset_target();
            }
        draw_surface(radialgrid_surf,0,0);
        }
        
    if (keyboard_check(ord('A')) or (guidelineshow == 1))
        {
        draw_guidelines();
        }
        
    draw_set_alpha(1);
    
    //selected elements
    draw_set_color(c_aqua);
    if !(ds_list_empty(semaster_list))//(selectedelement != -1)
        {
        if (update_semasterlist_flag)
            update_semasterlist();
        
        draw_sprite(spr_anchor,0,round(anchorx/$ffff*512),round(anchory/$ffff*512));
        draw_set_alpha(0.6);
        draw_sprite(spr_rotate,0,rectxmin,rectymax);
        draw_sprite(spr_resize,0,rectxmax,rectymax);
        draw_set_alpha(1);
        
        draw_rectangle(rectxmin,rectymin,rectxmax,rectymax,1);
        
        if (objmoving == 1) or (objmoving == 3) or (objmoving == 4)
            {
            xp1 = rectxmin+anixtrans/$ffff*512;
            yp1 = rectymin+aniytrans/$ffff*512;
            xp2 = rectxmax+anixtrans/$ffff*512;
            yp2 = rectymax+aniytrans/$ffff*512;
            xp3 = rectxmax+anixtrans/$ffff*512;
            yp3 = rectymin+aniytrans/$ffff*512;
            xp4 = rectxmin+anixtrans/$ffff*512;
            yp4 = rectymax+aniytrans/$ffff*512;
            rot_r = degtorad(anirot);
            
            angle1 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1));
            dist1 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1);
            
            xpnew1 = anchorx/$ffff*512+cos(rot_r-angle1)*dist1*scalex;
            ypnew1 = anchory/$ffff*512+sin(rot_r-angle1)*dist1*scaley;
            
            angle2 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2));
            dist2 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2);
            
            xpnew2 = anchorx/$ffff*512+cos(rot_r-angle2)*dist2*scalex;
            ypnew2 = anchory/$ffff*512+sin(rot_r-angle2)*dist2*scaley;
    
            angle3 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3));
            dist3 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3);
            
            xpnew3 = anchorx/$ffff*512+cos(rot_r-angle3)*dist3*scalex;
            ypnew3 = anchory/$ffff*512+sin(rot_r-angle3)*dist3*scaley;
            
            angle4 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4));
            dist4 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4);
            
            xpnew4 = anchorx/$ffff*512+cos(rot_r-angle4)*dist4*scalex;
            ypnew4 = anchory/$ffff*512+sin(rot_r-angle4)*dist4*scaley;
            
    
            draw_set_color(c_teal);
            draw_rectangle(xp1,yp1,xp2,yp2,1);
            
            draw_line(xpnew1,ypnew1,xpnew3,ypnew3);
            draw_line(xpnew2,ypnew2,xpnew3,ypnew3);
            draw_line(xpnew2,ypnew2,xpnew4,ypnew4);
            draw_line(xpnew4,ypnew4,xpnew1,ypnew1);
        
            if (objmoving == 1)
                {
                draw_set_alpha(0.4);
                    draw_arrow(mean(rectxmin,rectxmax),mean(rectymin,rectymax),mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),12);
                draw_set_alpha(1);
                }
            }
        
        }
    
    if (placing_status) or (placing == "text") or (placing == "hershey") 
        draw_preview_element();
}

//info text
draw_set_alpha(0.8);
draw_set_font(fnt_tooltip);

    draw_set_color(c_ltgray);
    draw_text(12,495,"Frame: "+string(frame+1)+"/"+string(maxframes));
    
    if (frame_complexity == 1)
        draw_set_color(c_red);
    else if (frame_complexity == 2)
        draw_set_color(c_orange);
    else 
        draw_set_color(c_ltgray);
    draw_text(440,495,"Points: "+string(framepoints));
    
    if (!anienable) and (maxframes &lt; 2)
        draw_set_color(c_gray);
    else 
        draw_set_color(c_ltgray);
    if (scope_start == 0) and (scope_end == maxframes-1)
        draw_text(220,495,"Scope: All frames");
    else
        draw_text(220,495,"Scope: "+string(scope_start+1)+" - "+string(scope_end+1));
    
draw_set_colour(c_black);
draw_set_alpha(1);

//menu
draw_text(0,view_yview[3]+4,menu_string);
if (mouse_y &gt; view_yview[3])   
    {
    draw_set_colour(c_teal);
    if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
        draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
        draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
        draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
        draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
        draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
        draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
        draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,0);
        }
    draw_set_alpha(1);
    }
draw_set_colour(c_white);

draw_enable_alphablend(0);
with (obj_button_parent)
    {
    draw_self();
    }
draw_enable_alphablend(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="48">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
frame = 0;
framehr = 0;
frame_surf_refresh = 1;


ds_list_clear(semaster_list);
update_semasterlist_flag = 1;

if (seqcontrol.song)
    FMODInstanceSetPaused(seqcontrol.songinstance,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (placing == "curve") and (placing_status == 2)
    create_element();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

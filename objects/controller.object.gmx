<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>version = "1.0.2";
versiondate = "2015-07-17";

FS_gmfilesystem_initialize(1);
FStemp = "%appdata%\LasershowGen\temp\";
FS_set_gm_save_area("%appdata%\LasershowGen\temp");
FS_set_working_directory("%appdata%\LasershowGen\temp");

//clean temp files
//FS_clean_temporary();
if (FS_directory_exists(FStemp))
    {
    while (1)
        {
        file = FS_file_find_first(FStemp+"*", 0);
        show_debug_message(file)
        if (file == "") or is_undefined(file) or !is_string(file)
            break;
        FS_file_delete(FStemp+file);
        if (FS_file_exists(FStemp+file))
            break;
        }
    }
else
    FS_directory_create(FStemp);

//declarations and setup
math_set_epsilon(0.00001);
ds_set_precision(0.00001); 
draw_set_circle_precision(24);

varmap = ds_map_create();
parser_shape = ML_InitParserScience(varmap);
    ML_AddVariable(parser_shape, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "max",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_shape, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
varmap = ds_map_create();
parser_cb = ML_InitParserScience(varmap);
    ML_AddVariable(parser_cb, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchorx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchory",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "x",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "y",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "max",255, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_cb, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    
alarm[3] = 120;

radialgrid_surf = surface_create(512,512);
surface_set_target(radialgrid_surf);
    draw_radialgrid();
surface_reset_target();
squaregrid_surf = surface_create(512,512);
surface_set_target(squaregrid_surf);
    draw_grid();
surface_reset_target();

el_list = ds_list_create();
undo_list = ds_list_create();
frame_surf = surface_create(512,512);
frame3d_surf = surface_create(512,512);
frame_list = ds_list_create();
ds_list_add(frame_list,el_list);
free_list = ds_list_create();
bez_list = ds_list_create();
font_list = ds_list_create();
snap_list = ds_list_create();
selsurf = surface_create(512,512);
miniaudio_surf = surface_create(512,512);
hershey_preview_surf = -1;
copy_list = -1;
semaster_list = ds_list_create();
hershey_index_list = ds_list_create();
hershey_list = -1;
menu_surf = -1;

c_gold = make_colour_rgb(255,220,0);

el_id = 0;
projectfps = 30;
xdelta[32] = 0;
playing = 0;
update_verbose = 0;
updatereceived = 0;
serial = "";
frame_surf_refresh = 0;
refresh_miniaudio_flag = 1;
letter = "";
image_speed = 0;
font_type = -1;
hershey_moving = 0;
hershey_scrollw = 19;
hershey_scrollx = 0;
hershey_scrollh = 4930;
hershey_selected = 0;
dialog_open = 0;
regflag = 0;

redraw = 0;
sgridshow = 0;
rgridshow = 0;
sgriddouble = 0;
rgriddouble = 0;
guidelineshow = 0;
guidelinedouble = 0;

mouse_yprevious = mouse_y;
mouse_xprevious = mouse_x;

phi = 1.618;
tlw = 512;
tlh = 42;

tooltip = "";
bckimage = 0;
onion = 0;
onion_dropoff = 0.7;
onion_number = 2;
onion_alpha = 0.8;
scroll = 0;
viewmode = 0;
selectedelement = -1;
selectedelementlist = 0;
exp_optimize = 1;
getint = -1;
getstr = -1;
dialog = "";
selecting = 0;
scroll = 0;

opt_maxdist = 3000;

placing = "line";
startpos[1] = 0;
placing_status = 0;
wave_amp = 10000;
wave_period = 1;
pointx[20] = 0;
pointy[20] = 0;
wave_offset = 0;
bez_moving = 0;
font_size = 20;

resolution = "auto";
framepoints = 0;

reap_color = 1;
reap_blank = 1;
reap_removeoverlap = 0;
reap_trans = 1;
reap_interpolate = 1;

colormode = "solid";
colormode2 = 0;
color1 = c_white;
color2 = c_white;
enddotscolor = c_red;
color_period = 8192;
color_freq = 1;
color_dc = 0.5;
color_offset = 0;
color_blendmode = 0; //0 replace, 1 add, 2 subtract

blankmode = "solid";
blankmode2 = 0;
blank_period = 8192;
blank_dc = 0.5;
blank_freq = 4;
enddots = 0;
makedot = 0;
dotmultiply = 20;
blank_offset = 0;
blank_blendmode = 0; //0 replace, 1 and, 2 or, 3 xor

anienable = 0;
frame = 0;
framehr = 0;
frameprev = 0;
fillframes = 1;
maxframes = 1;
anicolor1 = c_white;
anicolor2 = c_white;
anienddotscolor = c_red;
anicolor_dc = 0.5;
aniblank_dc = 0.5;
aniblank_offset = 0;
anicolor_offset = 0;
aniwave_offset = 0;
anifunc = "saw";
aniwave_amp = 10000;
anirep = 1;

rot = 0;
anirot = 0;
scalex = 1;
scaley = 1;
aniscalex = 1;
aniscaley = 1;
anchorx = $8000;
anchory = $8000;
anixtrans = 0;
aniytrans = 0;
shaking = 0;
shaking_sdev = 5;
anishaking_sdev = 5;
scope_start = 0;
scope_end = 0;
objmoving = 0;

shapefunc_cp = 100;
shapefunc_string_x = "";
shapefunc_string_y = "";
colorfunc_string_1 = "";
colorfunc_string_2 = "";
colorfunc_string_3 = "";
blankfunc_string = "";

draw_set_font(fnt_tooltip);
menu_string = "   File      Properties      Edit      Tools      View      Options      About   ";
menu_width_start[0] = 0;
menu_width[0] = string_width("   File   ");
menu_width_start[1] = menu_width[0];
menu_width[1] = string_width("   Properties   ");
menu_width_start[2] = menu_width_start[1]+menu_width[1];
menu_width[2] = string_width("   Edit   ");
menu_width_start[3] = menu_width_start[2]+menu_width[2];
menu_width[3] = string_width("   Tools   ");
menu_width_start[4] = menu_width_start[3]+menu_width[3];
menu_width[4] = string_width("   View   ");
menu_width_start[5] = menu_width_start[4]+menu_width[4];
menu_width[5] = string_width("   Options   ");
menu_width_start[6] = menu_width_start[5]+menu_width[5];
menu_width[6] = string_width("   About   ");
menu_width_start[7] = menu_width_start[6]+menu_width[6];

if (os_browser == browser_not_a_browser)
    {
    init_palette();
    update_check();
    parse_parameter();
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
guidelinedouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game end

game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset undo

alarm[3] = 600;

while (ds_list_size(undo_list) &gt; 100)
    {
    show_debug_message("cleaning undo list");
    undo = ds_list_find_value(undo_list,0);
    ds_list_delete(undo_list,0);

    if (is_real(undo))
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'a')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'r')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'd')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'v')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'b')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'k')
        {
        //undo reapply elements
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    else if (string_char_at(undo,0) == 'l')
        {
        //undo delete
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
sgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
rgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
scroll = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

if (placing = "hershey")
    hershey_handle_scroll();

with (obj_cursor)
    {
    if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
        {
        image_index = 8;
        x = clamp(mouse_x,0,view_wview[0]-128);
        y = clamp(mouse_y,0,view_hview[0]-128);
        }
    else
        {
        x = mouse_x;
        y = mouse_y;
        }
    }
    
if (keyboard_check_pressed(vk_space))
    {
    playing = !playing;
    if (seqcontrol.song)
        {
        if (playing)
            {
            FMODInstanceSetPosition(seqcontrol.songinstance,(tlx+framehr)/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
            FMODInstanceSetPaused(seqcontrol.songinstance,0);
            }
        else
            FMODInstanceSetPaused(seqcontrol.songinstance,1);
        }
    }
    
else if (keyboard_check_pressed(vk_backspace))
    {
    deselect_object();
    }
    
else if (keyboard_check_pressed(ord('M')))
    {
    window_set_fullscreen(0);
    window_set_size(1100,693);
    }
    
else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('Z')))
    {
    undo_ilda();
    }
        
else if (keyboard_check_pressed(ord("0")))
    {
    ilda_cancel();
    frame = 0;
    framehr = 0;
    }
    
else if (keyboard_check_pressed(ord("P")))
    {
    viewmode++;
    if (viewmode &gt; 2)
        viewmode = 0;
    frame_surf_refresh = 1;
    }
        
else if (keyboard_check_released(vk_f11))
    window_set_fullscreen(!window_get_fullscreen());
    
else if (keyboard_check(vk_control)) and ds_list_size(el_list)
    {
    check_elementselect();
    }
    
//PASTE
if (keyboard_check(vk_control) and keyboard_check_pressed(ord('V')))
    {
    paste_object();
    }
    
if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
    {
    view_visible[2] = 1;
    view_xport[2] = clamp(obj_cursor.x-128,0,view_wview[0]-256);
    view_yport[2] = clamp(obj_cursor.y-128,0,view_hview[0]-256);
    }
else
    view_visible[2] = 0;
    
if (keyboard_check(ord('S'))) or (sgridshow == 1)
    {
    with (obj_cursor)
        move_snap(32,32);
    }
    
if (playing == 1)
    {
    framehr += delta_time/1000000*seqcontrol.projectfps*seqcontrol.playbackspeed;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
        frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
        {
        update_semasterlist_flag = 1;
        }
        
    if (frameprev != 0) and (frame == 0) and (seqcontrol.song)
        {
        FMODInstanceSetPosition(seqcontrol.songinstance,tlx/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
        }
    }

if (ds_list_size(el_list) &gt; 0)
    {
    if (keyboard_check(vk_alt) and (placing_status == 0))
        {
        if (keyboard_check(vk_control))
            {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),0)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),1)/128;
            }
        else
            {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),2)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),3)/128;
            }
        }
    else if (keyboard_check(ord('Q')))
        {
        nearestdist = 32;
        for (i = 0;i &lt; ds_list_size(el_list);i++)
            {
            templist =  ds_list_find_value(el_list,i);
            if (point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y) &lt; nearestdist)
                {
                obj_cursor.x = ds_list_find_value(templist,0)/128;
                obj_cursor.y = ds_list_find_value(templist,1)/128;
                nearestdist = point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y);
                }
            if (point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y) &lt; nearestdist)
                {
                obj_cursor.x = ds_list_find_value(templist,2)/128;
                obj_cursor.y = ds_list_find_value(templist,3)/128;
                nearestdist = point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y);
                }
            }
        
        }
    }
    
if (!surface_exists(frame_surf) || (!surface_exists(frame3d_surf) &amp;&amp; viewmode != 0))
    frame_surf_refresh = 1;

    
//SELECTED ELEMENT STUFFS
canrightclick = 1;
if !ds_list_empty(semaster_list)
    {
    if (objmoving) or ((mouse_x == clamp(mouse_x,0,532)) and (mouse_y == clamp(mouse_y,0,room_height)))
        {
        canrightclick = !handle_trans();
        }
    
    //COPY
    if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('C')))
        {
        copy_object();
        }
        
    //CUT
    else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('X')))
        {
        cut_object();
        }
        
    //DELETE
    else if (keyboard_check_pressed(vk_delete))
        {
        delete_object();
        }
    }

if (mouse_x == clamp(mouse_x,0,512)) and (mouse_y == clamp(mouse_y,0,512))
and (mouse_check_button_pressed(mb_right)) and (canrightclick)
    dropdown_empty();
    
//KEYBOARD RIGHT LEFT
if (keyboard_check(vk_left)) and (maxframes &gt; 1) and (placing_status == 0)
    {
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_left))
        {
        frame--;
        framehr--;
        scroll = 0;
        alarm[0] = 30;
        }
    else if (scroll)
        framehr -= delta_time/1000000*seqcontrol.projectfps;
    if (framehr &lt; -0.5)
        framehr+= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
        {
        update_semasterlist_flag = 1;
        }
    }
else if (keyboard_check(vk_right)) and (maxframes &gt; 1) and (placing_status == 0)
    {
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_right))
        {
        frame++;
        framehr++;
        scroll = 0;
        alarm[0] = 30;
        }
    else if (scroll)
        framehr += delta_time/1000000*seqcontrol.projectfps;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
        frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
        {
        update_semasterlist_flag = 1;
        }
    }
    
if (frame &gt;= maxframes)
    {
    frame = maxframes-1;
    framehr = maxframes-1;
    }
    
frameprev = frame;    

//guidelines
if (keyboard_check(ord('A')) or (guidelineshow == 1))
    {
    if  (keyboard_check_pressed(ord('A')))
        {
        if (guidelinedouble == 1)
            guidelineshow = !guidelineshow;
        alarm[5] = 30;
        guidelinedouble = 1;
        }
    }
   
//grids 
if (keyboard_check(ord('S')) or (sgridshow == 1))
    {
    if  (keyboard_check_pressed(ord('S')))
        {
        if (sgriddouble == 1)
            sgridshow = !sgridshow;
        alarm[2] = 30;
        sgriddouble = 1;
        }
    } 
if (keyboard_check(ord('R')) or (rgridshow == 1))
    {
    if  (keyboard_check_pressed(ord('R')))
        {
        if (rgriddouble == 1)
            rgridshow = !rgridshow;
        alarm[1] = 30;
        rgriddouble = 1;
        }
    }

if (keyboard_check_pressed(vk_tab))
    {
    if (os_browser != browser_not_a_browser)
        {
        show_message_async("Sorry, this timeline is not available in the web version yet");
        exit;
        }
    ilda_cancel();
    frame = 0;
    framehr = 0;
    if (seqcontrol.song)
        FMODInstanceSetPaused(seqcontrol.songinstance,1);
        
    room_goto(rm_seq);
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if ((mouse_x &gt; 550) or (mouse_y &gt; 550)) and (placing_status != 2) or (!ds_list_empty(semaster_list) and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
))
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }

if (placing_status == 1) and (placing != "text")
    {
    if (placing != "curve")
        create_element();
    else
        {
        placing_status = 2;
        point1x = startpos[0]+cos(-mousedir-pi/2)*100;
        if (point1x &gt; 500) or (point1x &lt; 10)
            point1x = startpos[0]+cos(-mousedir+pi/2)*100;
        point1y = startpos[1]+sin(-mousedir-pi/2)*100;
        if (point1y &gt; 500) or (point1y &lt; 10)
            point1y = startpos[1]+sin(-mousedir+pi/2)*100;
        point2x = endx+cos(-mousedir-pi/2)*100;
        if (point2x &gt; 500) or (point2x &lt; 10)
            point2x = endx+cos(-mousedir+pi/2)*100;
        point2y = endy+sin(-mousedir-pi/2)*100;
        if (point2y &gt; 500) or (point2y &lt; 10)
            point2y = endy+sin(-mousedir+pi/2)*100;
        ds_list_replace(bez_list,2,point1x);
        ds_list_replace(bez_list,3,point1y);
        ds_list_replace(bez_list,4,point2x);
        ds_list_replace(bez_list,5,point2y);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    }
    
bez_moving = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

//menu
if (mouse_y &gt; view_yview[3])   
    {
    if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
        dropdown_menu_ilda_file();
        }
    else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
        dropdown_menu_ilda_properties();
        }
    else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
        dropdown_menu_ilda_edit();
        }
    else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
        dropdown_menu_ilda_tools();
        }
    else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
        dropdown_menu_ilda_view();
        }
    else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
        dropdown_menu_ilda_settings();
        }
    else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
        dropdown_menu_ilda_about();
        }
    exit;
    }

if (instance_exists(oDropDown)) or (mouse_x &gt; 512) or (mouse_y &gt; 512) or (keyboard_check(vk_control))
    exit;

if !ds_list_empty(semaster_list)  and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
)
    exit;
    
ds_list_clear(semaster_list);

if ((keyboard_check(ord('E'))) and (placing_status != 2))
    {
    ds_list_add(undo_list,"bb"+string(color2));
    ds_list_add(undo_list,"b"+string(color1));
    color1 = draw_getpixel(obj_cursor.x,obj_cursor.y);
    exit;
    }

if ((mouse_x &gt; 515) or (mouse_y &gt; 515)) and (placing_status != 2)
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }
    
    
if (placing_status == 0)
    {
    placing_status = 1;
    startpos[0] = obj_cursor.x;
    startpos[1] = obj_cursor.y;
    if (placing == "text")
        create_text_init();
    else if (placing == "free")
        {
        ds_list_add(free_list,0);
        ds_list_add(free_list,0);
        }
    else if (placing == "curve")
        {
        bezier_coeffs(0,0,0,0,0,0,0,0);
        ds_list_add(bez_list,startpos[0]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        }
    }
    
else if (placing_status == 2) and (placing == "curve")
    {
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3)) &lt; 7)
        bez_moving = 1;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5)) &lt; 7)
        bez_moving = 2;
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1)) &lt; 7)
        bez_moving = 3;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7)) &lt; 7)
        bez_moving = 4;
    mouse_yprevious = mouse_y;
    mouse_xprevious = mouse_x;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (mouse_x &gt; 512) or (mouse_y &gt; 512)
    exit;


//ds_list_clear(semaster_list);
    
if (placing == "free")
    {
    if (placing_status == 1)
        {
        autoresflag = 0;
        if (is_string(resolution)) 
            {
            autoresflag = 1; 
            resolution = 512;
            }
        if (point_distance(startpos[0]+ds_list_find_value(free_list,ds_list_size(free_list)-2),startpos[1]+ds_list_find_value(free_list,ds_list_size(free_list)-1),mouse_x,mouse_y) &gt;= resolution/128)
            {
            ds_list_add(free_list,mouse_x-startpos[0]);
            ds_list_add(free_list,mouse_y-startpos[1]);
            }
        if (autoresflag)
            resolution = "auto";
        }
    }
else if (placing == "curve")
    {
    if (placing_status == 1)
        {
        mousedir = degtorad(point_direction(startpos[0],startpos[1],endx,endy));
        ds_list_replace(bez_list,6,endx);
        ds_list_replace(bez_list,7,endy);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    else if (placing_status == 2)
        {
        if (bez_moving == 1)
            {
            ds_list_replace(bez_list,2,ds_list_find_value(bez_list,2)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,3,ds_list_find_value(bez_list,3)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 2)
            {
            ds_list_replace(bez_list,4,ds_list_find_value(bez_list,4)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,5,ds_list_find_value(bez_list,5)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 3)
            {
            ds_list_replace(bez_list,0,ds_list_find_value(bez_list,0)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,1,ds_list_find_value(bez_list,1)+mouse_y-mouse_yprevious);
            startpos[0] = ds_list_find_value(bez_list,0);
            startpos[1] = ds_list_find_value(bez_list,1);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 4)
            {
            ds_list_replace(bez_list,6,ds_list_find_value(bez_list,6)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,7,ds_list_find_value(bez_list,7)+mouse_y-mouse_yprevious);
            endx = ds_list_find_value(bez_list,6);
            endy = ds_list_find_value(bez_list,7);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        }
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//what a mess

dialog_open = 0;

//Get integer
var new_id = ds_map_find_value(async_load, "id");
if (new_id == getint)
    {
    if (dialog == "update")
        {
        updatecheckenabled = ds_map_find_value(async_load, "status");
        ini_filename = "settings.ini";
        ini_open(ini_filename);
        ini_write_real("main","updatecheck",updatecheckenabled);
        ini_close();
        if (updatecheckenabled)
            {
            updateget = http_get("http://github.com/Grix/ildagen/raw/master/version.txt");
            }
        }  

    if ds_map_find_value(async_load, "status")
        {
        switch (dialog)
            {
            case "toseqreplace":
                {
                frames_toseq();
                
                break;
                }
          
            case "updatefound":
                {
                file = http_get_file("https://github.com/Grix/ildagen/raw/master/LasershowGen-"+versionnew+"-Installer.exe","update.exe");
                
                break;
                }      
            
            case "wavet":
              {
              wave_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "waveamp":
              {
              wave_amp = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "waveoffset":
              {
              wave_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "shapefuncpoints":
              {
              shapefunc_cp = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "colorfreq":
              {
              color_freq = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "colordc":
              {
              color_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "colorperiod":
              {
              color_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "coloroffset":
              {
              color_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankoffset":
              {
              blank_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankdc":
              {
              blank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "aniblankdc":
              {
              aniblank_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "blankperiod":
              {
              blank_period = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "blankfreq":
              {
              blank_freq = ds_map_find_value(async_load, "value");
              
              break;
              }
              
            //ANI
            case "aniblankoffset":
              {
              aniblank_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "anicolordc":
              {
              anicolor_dc = clamp(ds_map_find_value(async_load, "value"),0,1);
              
              break;
              }
            case "anicoloroffset":
              {
              anicolor_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "aniwaveoffset":
              {
              aniwave_offset = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "aniwaveamp":
              {
              aniwave_amp = ds_map_find_value(async_load, "value");
              
              break;
              }
              
              //COLOR
            case "c1r":
              {
              color1 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color1),colour_get_blue(color1));
              
              break;
              }
            case "c1g":
              {
              color1 = make_color_rgb(colour_get_red(color1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color1));
              
              break;
              }
            case "c1b":
              {
              color1 = make_color_rgb(colour_get_red(color1),colour_get_green(color1),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "c2r":
              {
              color2 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(color2),colour_get_blue(color2));
              
              break;
              }
            case "c2g":
              {
              color2 = make_color_rgb(colour_get_red(color2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(color2));
              
              break;
              }
            case "anirep":
              {
              anirep = ds_map_find_value(async_load, "value");
              break;
              }
            case "c2b":
              {
              color2 = make_color_rgb(colour_get_red(color2),colour_get_green(color2),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "c3r":
              {
              enddotscolor = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(enddotscolor),colour_get_blue(enddotscolor));
              
              break;
              }
            case "c3g":
              {
              enddotscolor = make_color_rgb(colour_get_red(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(enddotscolor));
              
              break;
              }
            case "c3b":
              {
              enddotscolor = make_color_rgb(colour_get_red(enddotscolor),colour_get_green(enddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
              //ANI COLOR
            case "ac1r":
              {
              anicolor1 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor1),colour_get_blue(anicolor1));
              
              break;
              }
            case "ac1g":
              {
              anicolor1 = make_color_rgb(colour_get_red(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor1));
              
              break;
              }
            case "ac1b":
              {
              anicolor1 = make_color_rgb(colour_get_red(anicolor1),colour_get_green(anicolor1),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "ac2r":
              {
              anicolor2 = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anicolor2),colour_get_blue(anicolor2));
              
              break;
              }
            case "ac2g":
              {
              anicolor2 = make_color_rgb(colour_get_red(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anicolor2));
              
              break;
              }
            case "ac2b":
              {
              anicolor2 = make_color_rgb(colour_get_red(anicolor2),colour_get_green(anicolor2),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
            case "ac3r":
              {
              anienddotscolor = make_color_rgb(clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_green(anienddotscolor),colour_get_blue(anienddotscolor));
              
              break;
              }
            case "ac3g":
              {
              anienddotscolor = make_color_rgb(colour_get_red(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255),colour_get_blue(anienddotscolor));
              
              break;
              }
            case "ac3b":
              {
              anienddotscolor = make_color_rgb(colour_get_red(anienddotscolor),colour_get_green(anienddotscolor),clamp(ds_map_find_value(async_load, "value"),0,255));
              
              break;
              }
              
            case "aniscale":
              {
              scalex = ds_map_find_value(async_load, "value");
              scaley = scalex;
              reapply_trans();
              
              /*xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
              yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
              rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
              rectymin = yo + (ds_list_find_value(selectedelementlist,6));
              rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
              rectymax = yo + (ds_list_find_value(selectedelementlist,7));*/
              
              break;
              }            
              
            case "anirot":
              {
              anirot = ds_map_find_value(async_load, "value");
              reapply_trans();
              
              /*xo = ds_list_find_value(selectedelementlist,0)/$ffff*512;
              yo = ds_list_find_value(selectedelementlist,1)/$ffff*512;
              rectxmin = xo + (ds_list_find_value(selectedelementlist,4));
              rectymin = yo + (ds_list_find_value(selectedelementlist,6));
              rectxmax = xo + (ds_list_find_value(selectedelementlist,5));
              rectymax = yo + (ds_list_find_value(selectedelementlist,7));*/
              
              break;
              }
            
            case "clearall":
              {
              clear_all();
              
              break;
              }
              
            case "loadfile":
              {
              load_frames(get_open_filename_ext("LasershowGen frames|*.igf","","","Select LasershowGen frames file"));
              
              break;
              }
            
            case "dotintensity":
              {
              ds_list_add(undo_list,"d"+string(dotmultiply))
            
              dotmultiply = ds_map_find_value(async_load, "value");
              if (dotmultiply &lt; 1) dotmultiply = 1;
              if (dotmultiply &gt; 32) dotmultiply = 32;
              
              break;
              }
            case "onion_number":
              {
              onion_number = ds_map_find_value(async_load, "value");
              frame_surf_refresh = 1;
              
              break;
              }
            case "onion_alpha":
              {
              onion_alpha = clamp(ds_map_find_value(async_load, "value"),0,1);
              frame_surf_refresh = 1;
              
              break;
              }
            case "onion_dropoff":
              {
              onion_dropoff = clamp(ds_map_find_value(async_load, "value"),0,1);
              frame_surf_refresh = 1;
              
              break;
              }
            case "fontsize":
              {
              font_size = clamp(ds_map_find_value(async_load, "value"),1,128);
              break;
              }
              
            case "res":
              {
              ds_list_add(undo_list,"r"+string(resolution))
            
              resolution = ds_map_find_value(async_load, "value");
              if (resolution &lt; 4) resolution = 4;
              if (resolution &gt; $8000) resolution = $8000;
              
              break;
              }
              
            case "scopestart":
              {
              scope_start = clamp(ds_map_find_value(async_load, "value")-1,0,scope_end-1);
              frame = scope_start;
              framehr = scope_start;
              frame_surf_refresh = 1;
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "scopeend":
              {
              scope_end = clamp(ds_map_find_value(async_load, "value")-1,scope_start+1,maxframes-1);
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "fps":
              {
              seqcontrol.projectfps = clamp(ds_map_find_value(async_load, "value"),1,999);
              projectfps = seqcontrol.projectfps;
              refresh_miniaudio_flag = 1;
              
              break;
              }
              
            case "shaking_sdevset":
              {
              shaking_sdev = ds_map_find_value(async_load, "value");
              
              break;
              }
            case "anishaking_sdevset":
              {
              anishaking_sdev = ds_map_find_value(async_load, "value");
              
              break;
              }
              
            case "maxframes":
              {
              ds_list_add(undo_list,"a"+string(maxframes))
              
              refresh_miniaudio_flag = 1;
              
              scopeflag = 0;
              if (maxframes == (scope_end+1)) scopeflag = 1;
              
              maxframes = ds_map_find_value(async_load, "value");
              
              if (maxframes &lt; 1) maxframes = 1;
              else if (maxframes &gt; $ffff) maxframes = $ffff;
              
              if (scopeflag) or (scope_end &gt;= maxframes) 
                  scope_end = maxframes-1;
              
              if (scope_start &gt;= scope_end)
                  scope_start = scope_end-1;
                  
              if (scope_start &lt; 0) scope_start = 0;
              
              if (ds_list_size(frame_list) &lt; maxframes)
                  repeat (maxframes - ds_list_size(frame_list))
                      {
                      templist = ds_list_create();
                      if (fillframes)
                          {
                          tempelcount = ds_list_size(ds_list_find_value(frame_list,ds_list_size(frame_list)-1));
                          for (u = 0;u &lt; tempelcount;u++)
                              {
                              tempellist = ds_list_create();
                              ds_list_copy(tempellist,ds_list_find_value(ds_list_find_value(frame_list,ds_list_size(frame_list)-1),u));
                              ds_list_add(templist,tempellist);
                              }
                          }
                      ds_list_add(frame_list,templist);
                      }
              /*else
                  repeat (ds_list_size(frame_list)-maxframes)
                      {
                      el_list_temp = ds_list_find_value(frame_list,ds_list_size(frame_list)-1);
                      //for (u = 0;u &lt; ds_list_size(el_list_temp);u++)
                      //    ds_list_destroy(ds_list_find_value(el_list_temp,u));
                      ds_list_destroy(el_list_temp);
                      }*/
              if (frame &gt; maxframes) 
                  {
                  frame = maxframes-1;
                  framehr = maxframes-1;
                  }
                  
              dd_scope_reset();
              
              break;
              }
              
            }
        }
    }
else if (new_id == getstr)
    {
    if ds_map_find_value(async_load, "status")
       {
      if ds_map_find_value(async_load, "result") != ""
          {
          switch (dialog)
            {
            case ("funcx"):
                {
                shapefunc_string_x = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcy"):
                {
                shapefunc_string_y = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func1"):
                {
                colorfunc_string_1 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func2"):
                {
                colorfunc_string_2 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("func3"):
                {
                colorfunc_string_3 = ds_map_find_value(async_load, "result");
                break;
                }
            case ("funcen"):
                {
                blankfunc_string = ds_map_find_value(async_load, "result");
                break;
                }
            case ("text"):
                {
                text = ds_map_find_value(async_load, "result");

                for (i = 0;i &lt;= maxframes;i++)
                    xdelta[i] = 0;
                
                //start making elements
                for (texti = 1; texti &lt;= string_length(text);texti++)
                    {
                    letter = string_char_at(text,texti);
                    if (ord(letter) != clamp(ord(letter),33,126))
                        {
                        for (i = 0;i &lt;= maxframes;i++)
                            xdelta[i] += font_size*1.3;
                        }
                    else
                        {
                        create_element();
                        }
                    }
                    
                frame_surf_refresh = 1;
                break;
                }
            case ("exporthtml5"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                export_ilda_html5();
                break;
                }
            case ("saveframes"):
                {
                file_loc = ds_map_find_value(async_load, "result");
                save_frames_html5();
                break;
                }
            case ("serial"):
                {
                serial = ds_map_find_value(async_load, "result");
                with (obj_export)
                    {
                    controller.serialfile = file_text_open_write("serial");
                    file_text_write_string(controller.serialfile,controller.serial);
                    file_text_close(controller.serialfile);
                    show_message_async("Registered successfully");
                    }
                break;
                }
            }
          }
      }
    }
    
update_colors();
update_anicolors();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if (!updatecheckenabled)
//    exit;
    
if ds_map_find_value(async_load, "id") == updateget
    {
    if ds_map_find_value(async_load, "status") == 0
       {
       versionnew = ds_map_find_value(async_load, "result");
       show_debug_message("Checking version")
       if (versionnew != version)
            {
            ilda_dialog_yesno("updatefound","New version available: "+versionnew+"##Would you like to download and install the update?");
            }
       else if (update_verbose == 1)
            {
            show_message_async("Current version is up to date.");
            }
       }
    }
else if ds_map_find_value(async_load, "id") == file
    {
    if (file_exists("update.exe"))
        {
        if (alarm[4] == -1)
            {
            url_open("update.exe");
            alarm[4] = 30;
            }
        }
    else 
        {
        if (updatereceived == 0)
            {
            show_message_async("Failed to automatically download update. Opening download website..");
            url_open("http://bitlasers.com/opencart/index.php?route=product/product&amp;path=67&amp;product_id=82");
            updatereceived = 1;
            }
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>refresh_miniaudio_flag = 1;
frame_surf_refresh = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_exists(oDropDown)) exit;

if (tooltip != "")
    {
    draw_set_alpha(0.7);
    draw_set_color(c_black);
    draw_rectangle(0,0,string_width(tooltip)+20,string_height(tooltip)+10,0);
    draw_set_color(c_white);
    draw_set_alpha(1);
    draw_text(5,5,tooltip);
    tooltip = "";
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;

if (placing = "hershey")
    {
    draw_background_part(bck_hershey1,0,clamp(hershey_scrollx,0,2048),420,120,650,30);
    draw_background_part(bck_hershey2,0,clamp(hershey_scrollx-2048,0,2048),420,120-clamp(2048-hershey_scrollx,0,120),650,30+clamp(2048-hershey_scrollx,0,120));
    draw_background_part(bck_hershey3,0,clamp(hershey_scrollx-4096,0,2048),420,120-clamp(4096-hershey_scrollx,0,120),650,30+clamp(4096-hershey_scrollx,0,120));
    
    draw_set_alpha(1);
    draw_set_colour(c_white);
    draw_rectangle(1070,30,1090,150,0);
    draw_set_colour(c_black);
    draw_rectangle(1070,30,1090,150,1);
    draw_set_colour(c_dkgray);
    draw_rectangle(1070,30+hershey_scrollx*100/hershey_scrollh,1090,30+hershey_scrollx*100/hershey_scrollh+hershey_scrollw,0);
    
    yo = ceil((hershey_selected+1)/14)*30-30;
    if (yo = clamp(yo,hershey_scrollx-30,hershey_scrollx+120))
        {
        draw_set_alpha(0.3)
        draw_set_colour(c_gold);
        xo = (hershey_selected mod 14)*30;
        draw_rectangle(650+xo,max(30+yo-hershey_scrollx,30),680+xo,min(30+yo-hershey_scrollx+30,150),0);
        }
    }

if (!surface_exists(miniaudio_surf) || refresh_miniaudio_flag)
    {
    refresh_miniaudio_surf();
    refresh_miniaudio_flag = 0;
    }
    
draw_set_color(c_white);
    draw_ilda_2d();
    
draw_set_color(c_white);
draw_set_alpha(1);
if (surface_exists(miniaudio_surf))
    draw_surface_part(miniaudio_surf,0,0,tlw,tlh+1,0,515);
if (maxframes &gt; 1)
    {
    draw_set_color(c_black);
    cursorlinex = lerp(2,510,frame/(maxframes-1))//framehr/projectfps/1000;//framehr/1000*projectfps;
    draw_line(cursorlinex,515,cursorlinex,515+tlh-13);
    }
draw_set_color(c_white);

if (bckimage)
    {
    if (!keyboard_check(ord('E')))
        draw_set_alpha(0.3);
    if (sprite_exists(bck_bckimage))
        {
        draw_sprite_stretched(bck_bckimage,0,bckimage_left,bckimage_top,bckimage_width,bckimage_height);
        }
    else bckimage = 0;
    }
    
if (tooltip == "Click to select this object")
    {
    draw_set_alpha(0.5);
    draw_set_colour(c_teal);
        draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
    draw_set_alpha(1);
    draw_set_colour(c_white);
    }
else if (tooltip == "Click to deselect this object")
    {
    draw_set_alpha(0.7);
    draw_set_colour(c_maroon);
        draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
    draw_set_alpha(1);
    draw_set_colour(c_white);
    }

draw_set_color(c_gray);
if (objmoving == 3)
    draw_text(20,20,string_format(anirot,3,2)+" deg");
else if (objmoving == 1)
    {
    draw_text(20,20,"X translation: "+string_format(anixtrans,5,0));
    draw_text(20,40,"Y translation: "+string_format(aniytrans,5,0));
    }
else if (objmoving == 2)
    {
    draw_text(20,20,"Anchor X: "+string_format(anchorx,5,0));
    draw_text(20,40,"Anchor Y: "+string_format(anchory,5,0));
    }
else if (objmoving == 4)
    {
    draw_text(20,20,"X scale: "+string_format(scalex,2,3));
    draw_text(20,40,"Y scale: "+string_format(scaley,2,3));
    }
draw_set_color(c_white);
    
draw_set_alpha(1);

if (keyboard_check(ord('A')) or (guidelineshow == 1))
    {
    draw_guidelines();
    }
   
//grids 
if (keyboard_check(ord('S')) or (sgridshow == 1))
    {
    if (!surface_exists(squaregrid_surf))
        {
        squaregrid_surf = surface_create(512,512);
        surface_set_target(squaregrid_surf);
            draw_grid();
        surface_reset_target();
        }
    draw_surface(squaregrid_surf,0,0);
    } 
if (keyboard_check(ord('R')) or (rgridshow == 1))
    {
    if (!surface_exists(radialgrid_surf))
        {
        radialgrid_surf = surface_create(512,512);
        surface_set_target(radialgrid_surf);
            draw_radialgrid();
        surface_reset_target();
        }
    draw_surface(radialgrid_surf,0,0);
    }
    

//selected elements
draw_set_color(c_aqua);
if !(ds_list_empty(semaster_list))//(selectedelement != -1)
    {
    if (update_semasterlist_flag)
        update_semasterlist();
    
    draw_sprite(spr_anchor,0,anchorx/$ffff*512,anchory/$ffff*512);
    draw_set_alpha(0.6);
    draw_sprite(spr_rotate,0,rectxmin,rectymax);
    draw_sprite(spr_resize,0,rectxmax,rectymax);
    draw_set_alpha(1);
    
    draw_rectangle(rectxmin,rectymin,rectxmax,rectymax,1);
    
    if (objmoving == 1) or (objmoving == 3) or (objmoving == 4)
        {
        xp1 = rectxmin+anixtrans/$ffff*512;
        yp1 = rectymin+aniytrans/$ffff*512;
        xp2 = rectxmax+anixtrans/$ffff*512;
        yp2 = rectymax+aniytrans/$ffff*512;
        xp3 = rectxmax+anixtrans/$ffff*512;
        yp3 = rectymin+aniytrans/$ffff*512;
        xp4 = rectxmin+anixtrans/$ffff*512;
        yp4 = rectymax+aniytrans/$ffff*512;
        rot_r = degtorad(anirot);
        
        angle1 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1));
        dist1 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1);
        
        xpnew1 = anchorx/$ffff*512+cos(rot_r-angle1)*dist1*scalex;
        ypnew1 = anchory/$ffff*512+sin(rot_r-angle1)*dist1*scaley;
        
        angle2 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2));
        dist2 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2);
        
        xpnew2 = anchorx/$ffff*512+cos(rot_r-angle2)*dist2*scalex;
        ypnew2 = anchory/$ffff*512+sin(rot_r-angle2)*dist2*scaley;

        angle3 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3));
        dist3 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3);
        
        xpnew3 = anchorx/$ffff*512+cos(rot_r-angle3)*dist3*scalex;
        ypnew3 = anchory/$ffff*512+sin(rot_r-angle3)*dist3*scaley;
        
        angle4 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4));
        dist4 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4);
        
        xpnew4 = anchorx/$ffff*512+cos(rot_r-angle4)*dist4*scalex;
        ypnew4 = anchory/$ffff*512+sin(rot_r-angle4)*dist4*scaley;
        

        draw_set_color(c_teal);
        draw_rectangle(xp1,yp1,xp2,yp2,1);
        
        draw_line(xpnew1,ypnew1,xpnew3,ypnew3);
        draw_line(xpnew2,ypnew2,xpnew3,ypnew3);
        draw_line(xpnew2,ypnew2,xpnew4,ypnew4);
        draw_line(xpnew4,ypnew4,xpnew1,ypnew1);
    
        //draw_set_alpha(0.6);
            //draw_arrow(mean(rectxmin,rectxmax),mean(rectymin,rectymax),mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),12);
            //draw_arrow(mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),mean(xpnew1,xpnew2)+sin(rot_r)*48,mean(ypnew1,ypnew2)-cos(rot_r)*48,9);
        //draw_set_alpha(1);
        }
    
    }

draw_set_color(c_gray);

if (placing_status) or (placing == "text") or (placing == "hershey") 
    draw_preview_element();

//info
draw_set_alpha(0.8);
draw_set_font(fnt_tooltip);
draw_set_color(c_ltgray);
draw_text(12,495,"Frame: "+string(frame+1)+"/"+string(maxframes));
draw_text(440,495,"Points: "+string(framepoints));
if (!anienable) and (maxframes &lt; 2)
    draw_set_color(c_dkgray);
else draw_set_color(c_ltgray);
if (scope_start == 0) and (scope_end == maxframes-1)
    draw_text(220,495,"Scope: All frames");
else
    draw_text(220,495,"Scope: "+string(scope_start+1)+" - "+string(scope_end+1));
draw_set_colour(c_black);
draw_set_alpha(1);

//menu
draw_text(0,view_yview[3]+4,menu_string);
if (mouse_y &gt; view_yview[3])   
    {
    draw_set_colour(c_teal);
    if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
        draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
        draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
        draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
        draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
        draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
        draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,0);
        }
    else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
        draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,1);
        draw_set_alpha(0.3);
        draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,0);
        }
    draw_set_alpha(1);
    }
draw_set_colour(c_white);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="48">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
frame = 0;
framehr = 0;
frame_surf_refresh = 1;


ds_list_clear(semaster_list);
update_semasterlist_flag = 1;

if (seqcontrol.song)
    FMODInstanceSetPaused(seqcontrol.songinstance,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (placing == "curve") and (placing_status == 2)
    create_element();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

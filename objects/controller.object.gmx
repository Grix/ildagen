<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>version = "1.5.3";
versiondate = "2017-06-14";

if (debug_mode)
{
    show_debug_overlay(1);
    gml_release_mode(false);
}
else
{
    gml_release_mode(true);
}

//setup file handling system
FStemp = game_save_id+"temp\";
if (os_browser == browser_not_a_browser)
{
    if (directory_exists("temp"))
        directory_destroy("temp");
    directory_create("temp");
    
    var t_buf = buffer_create(1,buffer_fast,1);
    buffer_write(t_buf, buffer_u8, 1);
    buffer_save(t_buf,"temp\one");
}

//declarations and setup
//math_set_epsilon(0.00001);
//ds_set_precision(0.00001); 
draw_set_circle_precision(24);

varmap = ds_map_create();
parser_shape = ML_InitParserScience(varmap);
    ML_AddVariable(parser_shape, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_shape, "max",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_shape, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_shape, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
varmap = ds_map_create();
parser_cb = ML_InitParserScience(varmap);
    ML_AddVariable(parser_cb, "point",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "frame",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "startx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "starty",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchorx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "anchory",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endx",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "endy",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "pri_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_red",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_green",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "sec_blue",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "x",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "y",0, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "max",255, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "width",$ffff, ML_VAL_REAL, 1);
    ML_AddVariable(parser_cb, "height",$ffff, ML_VAL_REAL, 1);
    ML_AddFunction(parser_cb, "lerp", _ML_Lerp, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random", _ML_random, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    ML_AddFunction(parser_cb, "random_normal", _ML_random_gauss, ML_VAL_REAL,ML_VAL_REAL,ML_VAL_REAL);
    
alarm[3] = 120;

el_list = ds_list_create();
undo_list = ds_list_create();
frame_surf = surface_create(512,512);
frame3d_surf = surface_create(512,512);
frame_list = ds_list_create();
ds_list_add(frame_list,el_list);
free_list = ds_list_create();
bez_list = ds_list_create();
font_list = ds_list_create();
snap_list = ds_list_create();
selsurf = surface_create(512,512);
miniaudio_surf = surface_create(512,512);
hershey_preview_surf = -1;
copy_list = -1;
semaster_list = ds_list_create();
hershey_index_list = ds_list_create();
hershey_list = -1;
menu_surf = -1;
dac_list = ds_list_create();
blindzone_list = ds_list_create();
profile_list = ds_list_create();
list = ds_list_create();
emptyliststring = ds_list_write(list);
ds_list_destroy(list);

c_gold = make_colour_rgb(255,220,0);

adclosed = false;
dac = -1;
laseron = false;
laseronfirst = false;
el_id = 2;
projectfps = 30;
xdelta[32] = 0;
playing = 0;
update_verbose = 0;
updatereceived = 0;
serial = "";
frame_surf_refresh = 0;
refresh_miniaudio_flag = 1;
letter = "";
image_speed = 0;
font_type = -1;
hershey_moving = 0;
hershey_scrollw = 19;
hershey_scrollx = 0;
hershey_scrollh = 4930;
hershey_selected = 0;
dialog_open = false;
regflag = false;
menu_open = 0;
updateget = -1;
updatenotes = -1;
file = -1;
show_ad = true;
show_tooltip = true;
framecursor_prev = 0;
show_framecursor_prev = false;
scope_moving = false;

sgridshow = 0;
rgridshow = 0;
sgriddouble = 0;
rgriddouble = 0;
guidelineshow = 0;
guidelinedouble = 0;
sgridnum = 16;

mouse_yprevious = mouse_y;
mouse_xprevious = mouse_x;

phi = 1.618;
tlw = 512;
tlh = 42;
tlorigo_x = 0;
tlorigo_y = 515;

tooltip = "";
bckimage = 0;
onion = 0;
onion_dropoff = 0.7;
onion_number = 2;
onion_alpha = 0.8;
scroll = 0;
viewmode = 0;
selectedelement = -1;
selectedelementlist = 0;
exp_optimize = 1;
exp_format = 5;
opt_warning_flag = 0;
getint = -1;
getstr = -1;
dialog = "";
selecting = 0;
scrollcursor_flag = 0;

global.loading_exportproject = 0;
global.loading_exportilda = 0;
global.loading_exportildahtml5 = 0;
global.loading_saveproject = 0;
global.loading_loadproject = 0;
global.loading_importilda = 0;
global.loading_importfont = 0;
global.loading_importildaseq = 0;

opt_maxdist = 300;
opt_maxdwell = 5;
opt_maxdwell_blank = 1;
opt_blankshift = 0;
opt_redshift = 0;
opt_greenshift = 0;
opt_blueshift = 0;
opt_scanspeed = 30000;
invert_y = false;
invert_x = false;
projector = 0;
red_scale = 1;
blue_scale = 1;
green_scale = 1;
red_scale_lower = 0;
blue_scale_lower = 0;
green_scale_lower = 0;
angle_prev = 0;
x_scale_start = 0;
x_scale_end = $FFFF;
y_scale_start = 0;
y_scale_end = $FFFF;

placing = "line";
placing_select_last = "line";
object_select_hovering = 0;
startpos[1] = 0;
placing_status = 0;
wave_amp = 10000;
wave_period = 1;
pointx[20] = 0;
pointy[20] = 0;
wave_offset = 0;
bez_moving = 0;
font_size = 20;
preview_testframe = 0; //0: testframe, 1: editor mode, 2: timeline mode

resolution = "auto";
framepoints = 0;
frame_complexity = 0;

reap_color = 1;
reap_blank = 1;
reap_removeoverlap = 0;
reap_trans = 1;
reap_interpolate = 1;
rectxmax = 0;
rectxmin = 0;
rectymax = 0;
rectymin = 0;

colormode = "solid";
colormode2 = 0;
color1 = c_white;
color2 = c_white;
enddotscolor = c_red;
color_period = 8192;
color_freq = 1;
color_dc = 0.5;
color_offset = 0;
color_blendmode = 0; //0 replace, 1 add, 2 subtract

blankmode = "solid";
blankmode2 = 0;
blank_period = 8192;
blank_dc = 0.5;
blank_freq = 4;
blank = 0;
enddots = 0;
makedot = 0;
dotmultiply = 12;
blank_offset = 0;
blank_blendmode = 1; //0 replace, 1 and, 2 or, 3 xor

anienable = 0;
frame = 0;
framehr = 0;
frameprev = 0;
fillframes = 1;
maxframes = 1;
anicolor1 = c_white;
anicolor2 = c_white;
anienddotscolor = c_red;
anicolor_dc = 0.5;
aniblank_dc = 0.5;
aniblank_offset = 0;
anicolor_offset = 0;
aniwave_offset = 0;
anifunc = "saw";
aniwave_amp = 10000;
anirep = 1;

rot = 0;
anirot = 0;
scalex = 1;
scaley = 1;
aniscalex = 1;
aniscaley = 1;
anchorx = $8000;
anchory = $8000;
anixtrans = 0;
aniytrans = 0;
shaking = 0;
shaking_sdev = 5;
anishaking_sdev = 5;
scope_start = 0;
scope_end = 0;
objmoving = 0;
projectfps = 30;

shapefunc_cp = 100;
shapefunc_string_x = "";
shapefunc_string_y = "";
colorfunc_string_1 = "";
colorfunc_string_2 = "";
colorfunc_string_3 = "";
blankfunc_string = "";

draw_set_font(fnt_tooltip);
menu_string = "   File      Properties      Edit      Tools      View      Settings      About   ";
menu_width_start[0] = 0;
menu_width[0] = string_width("   File   ");
menu_width_start[1] = menu_width[0];
menu_width[1] = string_width("   Properties   ");
menu_width_start[2] = menu_width_start[1]+menu_width[1];
menu_width[2] = string_width("   Edit   ");
menu_width_start[3] = menu_width_start[2]+menu_width[2];
menu_width[3] = string_width("   Tools   ");
menu_width_start[4] = menu_width_start[3]+menu_width[3];
menu_width[4] = string_width("   View   ");
menu_width_start[5] = menu_width_start[4]+menu_width[4];
menu_width[5] = string_width("   Settings   ");
menu_width_start[6] = menu_width_start[5]+menu_width[5];
menu_width[6] = string_width("   About   ");
menu_width_start[7] = menu_width_start[6]+menu_width[6];

radialgrid_surf = surface_create(512,512);
surface_set_target(radialgrid_surf);
    draw_radialgrid();
surface_reset_target();
squaregrid_surf = surface_create(512,512);
surface_set_target(squaregrid_surf);
    draw_grid();
surface_reset_target();

randomize();

init_palette();

if (os_browser == browser_not_a_browser)
{
    update_check();
    parse_parameter();
    load_settings();
}

verify_serial(1);
telem();

ex_patch_window_close_capture(1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset menu_open

menu_open = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
guidelinedouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game end

game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean undo

alarm[3] = 1200;

while (ds_list_size(undo_list) &gt; 100)
    {
    show_debug_message("cleaning undo list");
    undo = ds_list_find_value(undo_list,0);
    ds_list_delete(undo_list,0);

    if (is_real(undo))
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'a')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'r')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'd')
        {
        //nothing
        }
    else if (string_char_at(undo,0) == 'v')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'b')
        {
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        ds_list_destroy(real(string_digits(undo)));
        }
    else if (string_char_at(undo,0) == 'k')
        {
        //undo reapply elements
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            if (ds_exists(list,ds_type_list))
                ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    else if (string_char_at(undo,0) == 'l')
        {
        //undo delete
        if (!ds_exists(real(string_digits(undo)),ds_type_list))
            continue;
        tempundolist = real(string_digits(undo));
        for (u = 0;u &lt; ds_list_size(tempundolist)-1;u++)
            {
            list = ds_list_find_value(tempundolist,u);
            if (ds_exists(list,ds_type_list))
                ds_list_destroy(list);
            }
        ds_list_destroy(tempundolist);
        }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
sgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
rgriddouble = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
scroll = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ex_patch_window_close_event())
    exit_confirm();
    
if (keyboard_check_pressed(ord('M')))
{
    window_set_fullscreen(0);
    window_set_size(room_width,room_height);
}
else if (keyboard_check_released(vk_f11))
    window_set_fullscreen(!window_get_fullscreen());
    
if (room == rm_loading)
{
    if (global.loading_exportilda == 1)
        export_ilda_work();
    else if (global.loading_exportildahtml5 == 1)
        export_ilda_html5_work();
    else if (global.loading_importilda == 1)
    {
        if (global.loading_current &lt; global.loading_end)
            read_ilda_work();
        else
            import_ilda_end();
    }
    else if (global.loading_importfont == 1)
    {
        if (global.loading_current &lt; global.loading_end)
            read_ilda_work();
        else
            import_font_end();
    }
}
    
with (obj_cursor)
{
    if (room == rm_ilda) and (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
    {
        image_index = 8;
        x = clamp(mouse_x,0,view_wview[0]-128);
        y = clamp(mouse_y,0,view_hview[0]-128);
    }
    else
    {
        x = mouse_x;
        y = mouse_y;
    }
}

if (room != rm_ilda) exit;

el_list = frame_list[| frame];

if (placing = "hershey")
    hershey_handle_scroll();
    
object_select_hovering = 0;

check_mouseactions();

if (keyboard_check_pressed(vk_space))
{
    playing = !playing;
    if (seqcontrol.song)
    {
        if (playing)
        {
            FMODInstanceSetPosition(seqcontrol.songinstance,(tlx+framehr)/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
            FMODInstanceSetPaused(seqcontrol.songinstance,0);
        }
        else
            FMODInstanceSetPaused(seqcontrol.songinstance,1);
    }
    
    if (!playing)
        refresh_miniaudio_flag = 1;
}
    
else if (keyboard_check_pressed(vk_backspace))
{
    deselect_object();
}
    
else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('Z')))
{
    undo_ilda();
}
        
else if (keyboard_check_pressed(ord("0")))
{
    ilda_cancel();
    frame = 0;
    framehr = 0;
    refresh_miniaudio_flag = 1;
}
    
else if (keyboard_check_pressed(ord("P")))
{
    viewmode++;
    if (viewmode &gt; 2)
        viewmode = 0;
    frame_surf_refresh = 1;
}
else if (keyboard_check_pressed(vk_escape))
{
    ds_list_clear(semaster_list);
        
    if (laseron)
    {
        laseron = false;
        frame_surf_refresh = true;
        dac_blank_and_center(dac);
    }
}
    
else if (keyboard_check(vk_control) or (placing == "select")) and ds_list_size(el_list)
{
    check_elementselect();
}
    
//PASTE
if (keyboard_check(vk_control) and keyboard_check_pressed(ord('V')))
{
    paste_object();
}
    
if (keyboard_check(ord('Z')) and !keyboard_check(vk_control))
{
    view_visible[2] = 1;
    view_xport[2] = clamp(obj_cursor.x-128,0,view_wview[0]-256);
    view_yport[2] = clamp(obj_cursor.y-128,0,view_hview[0]-256);
}
else
    view_visible[2] = 0;
    
if (keyboard_check(ord('S'))) or (sgridshow == 1)
{
    with (obj_cursor)
    {
        if (x &lt; 512) and (y &lt; 512)
            move_snap(512/controller.sgridnum,512/controller.sgridnum);
    }
}

if (ds_list_size(el_list) &gt; 0)
{
    if (keyboard_check(vk_alt) and (placing_status == 0))
    {
        if (keyboard_check(vk_control))
        {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),0)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),1)/128;
        }
        else
        {
            obj_cursor.x = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),2)/128;
            obj_cursor.y = ds_list_find_value(ds_list_find_value(el_list,ds_list_size(el_list)-1),3)/128;
        }
    }
    else if (keyboard_check(ord('Q')))
    {
        nearestdist = 32;
        for (i = 0;i &lt; ds_list_size(el_list);i++)
        {
            templist =  ds_list_find_value(el_list,i);
            if (point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y) &lt; nearestdist)
            {
                obj_cursor.x = ds_list_find_value(templist,0)/128;
                obj_cursor.y = ds_list_find_value(templist,1)/128;
                nearestdist = point_distance(ds_list_find_value(templist,0)/128,ds_list_find_value(templist,1)/128,mouse_x,mouse_y);
            }
            if (point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y) &lt; nearestdist)
            {
                obj_cursor.x = ds_list_find_value(templist,2)/128;
                obj_cursor.y = ds_list_find_value(templist,3)/128;
                nearestdist = point_distance(ds_list_find_value(templist,2)/128,ds_list_find_value(templist,3)/128,mouse_x,mouse_y);
            }
        }
        
    }
}
    
if (!surface_exists(frame_surf) || (!surface_exists(frame3d_surf) &amp;&amp; viewmode != 0))
    frame_surf_refresh = true;

    
//SELECTED ELEMENT STUFFS
canrightclick = 1;
if !ds_list_empty(semaster_list)
{
    canrightclick = !handle_trans();
    
    //COPY
    if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('C')))
    {
        copy_object();
    }
        
    //CUT
    else if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord('X')))
    {
        cut_object();
    }
        
    //DELETE
    else if (keyboard_check_pressed(vk_delete))
    {
        delete_object();
    }
}

if (mouse_x == clamp(mouse_x,0,512)) and (mouse_y == clamp(mouse_y,0,512))
and (mouse_check_button_pressed(mb_right)) and (canrightclick)
    dropdown_empty();
    
//KEYBOARD RIGHT LEFT
if (keyboard_check(vk_left)) and (maxframes &gt; 1) and (placing_status == 0)
{
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_left))
    {
        frame--;
        framehr--;
        scroll = 0;
        alarm[0] = 30;
    }
    else if (scroll)
        framehr -= delta_time/1000000*seqcontrol.projectfps;
    if (framehr &lt; -0.5)
        framehr+= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
        
    }
    refresh_miniaudio_flag = 1;
}
else if (keyboard_check(vk_right)) and (maxframes &gt; 1) and (placing_status == 0)
{
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    
    if (keyboard_check_pressed(vk_right))
    {
        frame++;
        framehr++;
        scroll = 0;
        alarm[0] = 30;
    }
    else if (scroll)
        framehr += delta_time/1000000*seqcontrol.projectfps;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = round(framehr);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
        frame_surf_refresh = 1;
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
    }
    refresh_miniaudio_flag = 1;
}
    
if (frame &gt;= maxframes)
{
    frame = maxframes-1;
    framehr = maxframes-1;
}
    
frameprev = frame;    

//guidelines
if (keyboard_check(ord('A')) or (guidelineshow == 1))
{
    if  (keyboard_check_pressed(ord('A')))
    {
        if (guidelinedouble == 1)
            guidelineshow = !guidelineshow;
        alarm[5] = 30;
        guidelinedouble = 1;
    }
}
   
//grids 
if (keyboard_check(ord('S')) or (sgridshow == 1))
{
    if  (keyboard_check_pressed(ord('S')))
    {
        if (sgriddouble == 1)
            sgridshow = !sgridshow;
        alarm[2] = 30;
        sgriddouble = 1;
    }
    if (keyboard_check_pressed(vk_up))
    {
        controller.sgridnum -= 1;
        if (controller.sgridnum &lt; 1)
            controller.sgridnum = 1;
        square_grid_refresh();
    }
    if (keyboard_check_pressed(vk_down))
    {
        controller.sgridnum += 1;
        square_grid_refresh();
    }
} 
if (keyboard_check(ord('R')) or (rgridshow == 1))
{
    if  (keyboard_check_pressed(ord('R')))
    {
        if (rgriddouble == 1)
            rgridshow = !rgridshow;
        alarm[1] = 30;
        rgriddouble = 1;
    }
}

if (keyboard_check_pressed(vk_tab))
{
    if (os_browser != browser_not_a_browser)
    {
        show_message_new("Sorry, the timeline is not available in the web version yet");
        exit;
    }
    ilda_cancel();
    frame = 0;
    framehr = 0;
    if (seqcontrol.song)
        FMODInstanceSetPaused(seqcontrol.songinstance,1);
        
    room_goto(rm_seq);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///timing and laser output
if (room != rm_ilda) exit;

if (playing == 1)
{
    if (maxframes &lt;= 1)
    {
        playing = 0;
        if (seqcontrol.song)
            FMODInstanceSetPaused(seqcontrol.songinstance,1);
    }
        
    framehr += delta_time/1000000*seqcontrol.projectfps*seqcontrol.playbackspeed;
    if (framehr &gt; maxframes-0.5)
        framehr-= maxframes;
    frame = clamp(round(framehr),0,maxframes-1);
    if (frame &lt; 1)
        frame = 0;
    if (frame != frameprev)
    {
        frame_surf_refresh = 1;
    }
    
    if !ds_list_empty(semaster_list)
    {
        update_semasterlist_flag = 1;
    }
        
    if (frameprev != 0) and (frame == 0) and (seqcontrol.song)
    {
        FMODInstanceSetPosition(seqcontrol.songinstance,tlx/seqcontrol.projectfps*1000/FMODSoundGetLength(seqcontrol.song));
    }
}

minroomspeed = 60;

if (laseron)
{
    if (!ds_exists(dac,ds_type_list))
    {
        show_message_new("Error, DAC data missing");
        laseron = false;
        dac = -1;
    }
    else
        output_frame();
}

room_speed = projectfps;
while (room_speed &lt; minroomspeed)
    room_speed += projectfps;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (instance_exists(oDropDown))
    exit;

if ((mouse_x &gt; 550) or (mouse_y &gt; 550)) and (placing_status != 2) or (!ds_list_empty(semaster_list) and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
))
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }

if (placing_status == 1) and (placing != "text") and (placing != "select")
    {
    if (placing != "curve")
        create_element();
    else
        {
        placing_status = 2;
        point1x = startpos[0]+cos(-mousedir-pi/2)*100;
        if (point1x &gt; 500) or (point1x &lt; 10)
            point1x = startpos[0]+cos(-mousedir+pi/2)*100;
        point1y = startpos[1]+sin(-mousedir-pi/2)*100;
        if (point1y &gt; 500) or (point1y &lt; 10)
            point1y = startpos[1]+sin(-mousedir+pi/2)*100;
        point2x = endx+cos(-mousedir-pi/2)*100;
        if (point2x &gt; 500) or (point2x &lt; 10)
            point2x = endx+cos(-mousedir+pi/2)*100;
        point2y = endy+sin(-mousedir-pi/2)*100;
        if (point2y &gt; 500) or (point2y &lt; 10)
            point2y = endy+sin(-mousedir+pi/2)*100;
        ds_list_replace(bez_list,2,point1x);
        ds_list_replace(bez_list,3,point1y);
        ds_list_replace(bez_list,4,point2x);
        ds_list_replace(bez_list,5,point2y);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    }
    
bez_moving = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
    
//menu
if (mouse_y &gt; view_yview[3])   
    {
    if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
        dropdown_menu_ilda_file();
        }
    else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
        dropdown_menu_ilda_properties();
        }
    else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
        dropdown_menu_ilda_edit();
        }
    else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
        dropdown_menu_ilda_tools();
        }
    else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
        dropdown_menu_ilda_view();
        }
    else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
        dropdown_menu_ilda_settings();
        }
    else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
        dropdown_menu_ilda_about();
        }
    exit;
    }

if (instance_exists(oDropDown)) or (mouse_x &gt; 512) or (mouse_y &gt; 512) or (keyboard_check(vk_control) or (placing == "select"))
    exit;

if !ds_list_empty(semaster_list)  and (
((mouse_x == clamp(mouse_x,rectxmin-2,rectxmax+2)) and (mouse_y == clamp(mouse_y,rectymin-2,rectymax+2)))
or ((mouse_x == clamp(mouse_x,anchorx/$ffff*512-10,anchorx/$ffff*512+10)) and (mouse_y == clamp(mouse_y,anchory/$ffff*512-10,anchory/$ffff*512+10)))
or ((mouse_x == clamp(mouse_x,rectxmin-20,rectxmin-2)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
or ((mouse_x == clamp(mouse_x,rectxmax+2,rectxmax+20)) and (mouse_y == clamp(mouse_y,rectymax+2,rectymax+20)))
)
    exit;
    
ds_list_clear(semaster_list);

if ((keyboard_check(ord('E'))) and (placing_status != 2))
    {
    ds_list_add(undo_list,"bb"+string(color2));
    ds_list_add(undo_list,"b"+string(color1));
    color1 = draw_getpixel(obj_cursor.x,obj_cursor.y+23);
    update_colors();
    exit;
    }

if ((mouse_x &gt; 515) or (mouse_y &gt; 515)) and (placing_status != 2)
    {
    placing_status = 0;
    ds_list_clear(free_list);
    ds_list_clear(bez_list);
    exit;
    }
    
    
if (placing_status == 0)
    {
    placing_status = 1;
    startpos[0] = obj_cursor.x;
    startpos[1] = obj_cursor.y;
    if (placing == "text")
        create_text_init();
    else if (placing == "free")
        {
        ds_list_add(free_list,0);
        ds_list_add(free_list,0);
        }
    else if (placing == "curve")
        {
        bezier_coeffs(0,0,0,0,0,0,0,0);
        ds_list_add(bez_list,startpos[0]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        ds_list_add(bez_list,startpos[1]);
        }
    }
    
else if (placing_status == 2) and (placing == "curve")
    {
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3)) &lt; 7)
        bez_moving = 1;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5)) &lt; 7)
        bez_moving = 2;
    if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1)) &lt; 7)
        bez_moving = 3;
    else if (point_distance(mouse_x,mouse_y,ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7)) &lt; 7)
        bez_moving = 4;
    mouse_yprevious = mouse_y;
    mouse_xprevious = mouse_x;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (mouse_x &gt; 512) or (mouse_y &gt; 512)
    exit;
if (instance_exists(oDropDown))
    exit;

    
if (placing == "free")
    {
    if (placing_status == 1)
        {
        autoresflag = 0;
        if (is_string(resolution)) 
            {
            autoresflag = 1; 
            resolution = 512;
            }
        if (point_distance(startpos[0]+ds_list_find_value(free_list,ds_list_size(free_list)-2),startpos[1]+ds_list_find_value(free_list,ds_list_size(free_list)-1),mouse_x,mouse_y) &gt;= resolution/128)
            {
            ds_list_add(free_list,mouse_x-startpos[0]);
            ds_list_add(free_list,mouse_y-startpos[1]);
            }
        if (autoresflag)
            resolution = "auto";
        }
    }
else if (placing == "curve")
    {
    if (placing_status == 1)
        {
        mousedir = degtorad(point_direction(startpos[0],startpos[1],endx,endy));
        ds_list_replace(bez_list,6,endx);
        ds_list_replace(bez_list,7,endy);
        bezier_coeffs(ds_list_find_value(bez_list,0),ds_list_find_value(bez_list,1),ds_list_find_value(bez_list,2),ds_list_find_value(bez_list,3),ds_list_find_value(bez_list,4),ds_list_find_value(bez_list,5),ds_list_find_value(bez_list,6),ds_list_find_value(bez_list,7));
        }
    else if (placing_status == 2)
        {
        if (bez_moving == 1)
            {
            ds_list_replace(bez_list,2,ds_list_find_value(bez_list,2)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,3,ds_list_find_value(bez_list,3)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 2)
            {
            ds_list_replace(bez_list,4,ds_list_find_value(bez_list,4)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,5,ds_list_find_value(bez_list,5)+mouse_y-mouse_yprevious);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 3)
            {
            ds_list_replace(bez_list,0,ds_list_find_value(bez_list,0)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,1,ds_list_find_value(bez_list,1)+mouse_y-mouse_yprevious);
            startpos[0] = ds_list_find_value(bez_list,0);
            startpos[1] = ds_list_find_value(bez_list,1);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        else if (bez_moving == 4)
            {
            ds_list_replace(bez_list,6,ds_list_find_value(bez_list,6)+mouse_x-mouse_xprevious);
            ds_list_replace(bez_list,7,ds_list_find_value(bez_list,7)+mouse_y-mouse_yprevious);
            endx = ds_list_find_value(bez_list,6);
            endy = ds_list_find_value(bez_list,7);
            mouse_yprevious = mouse_y;
            mouse_xprevious = mouse_x;
            }
        }
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>process_dialog_ilda(async_load);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>process_dialog_ilda(async_load);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if (!updatecheckenabled)
//    exit;
    
if (ds_map_find_value(async_load, "id") == updateget)
{
    if ds_map_find_value(async_load, "status") == 0
   {
       versionnew = ds_map_find_value(async_load, "result");
       log("Checking version")
       if (versionnew != version)
        {
            ilda_dialog_yesno("updatefound","New version available: "+versionnew+"#"+"Would you like to download and install the update?##"+releasenotes+"##");
        }
       else if (update_verbose == 1)
        {
            show_message_new("Current version is up to date.");
        }
   }
}
else if (ds_map_find_value(async_load, "id") == updatenotes)
{
    if ds_map_find_value(async_load, "status") == 0
   {
       releasenotes = ds_map_find_value(async_load, "result");
       updateget = http_get("https://raw.githubusercontent.com/Grix/ildagen/master/version.txt");
   }
}
else if (ds_map_find_value(async_load, "id") == file)
{
     if ds_map_find_value(async_load, "status") == 0
    {
        if (file_exists("temp/update.exe"))
        {
            if (alarm[4] == -1)
            {
                show_message_new("Launching installer");
                url_open_new(FStemp+"update.exe")
                alarm[4] = 60;
            }
        }
        else 
        {
            if (updatereceived == 0)
            {
                show_message_new("Failed to automatically download update. Opening download website..");
                url_open_new("http://pages.bitlasers.com/lasershowgen/");
                updatereceived = 1;
            }
        }
     }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (laseron)
    dac_blank_and_center_all(dac);

refresh_miniaudio_flag = 1;
frame_surf_refresh = 1;
laseron = false;
menu_open = 0;
dialog_open = 0;
playing = false;
with (seqcontrol)
{
    playing = false;
    frame_surf_refresh = true;
    output_buffer_ready = false;
    if (song)
        FMODInstanceSetPaused(songinstance,1);
}
output_buffer_ready = false;

if (room == rm_ilda)
    window_set_caption("LasershowGen - Editor Mode");
else if (room == rm_seq)
    window_set_caption("LasershowGen - Timeline Mode");
else if (room == rm_options)
    window_set_caption("LasershowGen - Settings");
else if (room == rm_loading)
    window_set_caption("LasershowGen - Working...");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>save_settings();
FMODfree();
UnloadFMOD();
close_dacs();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (view_current != 0)
    exit;
    
if (tooltip != "")
{
    if (show_tooltip)
    {
        draw_set_alpha(0.8);
        draw_set_color(c_black);
        draw_rectangle(0,0,string_width(tooltip)+20,string_height(tooltip)+10,0);
        draw_set_color(c_white);
        draw_set_alpha(1);
        draw_text(5,5,tooltip);
    }
    tooltip = "";
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) 
    exit;
if (view_current == 0)
{
    //hershey symbol selector
    if (placing = "hershey")
    {
        draw_background_part(bck_hershey3,0,clamp(hershey_scrollx-4096,0,2048),420,120-clamp(4096-hershey_scrollx,0,120),650,30+clamp(4096-hershey_scrollx,0,120));
        draw_background_part(bck_hershey2,0,clamp(hershey_scrollx-2048,0,2048),420,120-clamp(2048-hershey_scrollx,0,120),650,30+clamp(2048-hershey_scrollx,0,120));
        draw_background_part(bck_hershey1,0,clamp(hershey_scrollx,0,2048),420,120,650,30);
        
        draw_set_alpha(1);
        draw_set_colour(c_white);
        draw_rectangle(1070,30,1090,150,0);
        draw_set_colour(c_black);
        draw_rectangle(1070,30,1090,150,1);
        draw_set_colour(c_dkgray);
        draw_rectangle(1070,30+hershey_scrollx*100/hershey_scrollh,1090,30+hershey_scrollx*100/hershey_scrollh+hershey_scrollw,0);
        
        yo = ceil((hershey_selected+1)/14)*30-30;
        if (yo = clamp(yo,hershey_scrollx-30,hershey_scrollx+120))
        {
            draw_set_alpha(0.3)
            draw_set_colour(c_gold);
            xo = (hershey_selected mod 14)*30;
            draw_rectangle(650+xo,max(30+yo-hershey_scrollx,30),680+xo,min(30+yo-hershey_scrollx+30,150),0);
        }
    }
    
    //mine timeline + cursors
    if (!surface_exists(miniaudio_surf) || refresh_miniaudio_flag)
    {
        refresh_miniaudio_surf();
        refresh_miniaudio_flag = 0;
    }
    draw_set_color(c_white);
    draw_set_alpha(1);
    if (surface_exists(miniaudio_surf))
        draw_surface_part(miniaudio_surf,0,0,tlw,tlh+1,tlorigo_x,tlorigo_y);
    if (maxframes &gt; 1)
    {
        draw_set_color(c_black);
        cursorlinex = lerp(2,tlw-2,frame/(maxframes-1));
        draw_line(cursorlinex,tlorigo_y,cursorlinex,tlorigo_y+tlh-13);
        if (show_framecursor_prev)
        {
            draw_set_alpha(0.6);
            draw_set_color(c_teal);
            cursorlinex = lerp(2,tlw-2,framecursor_prev/(maxframes-1));
            draw_line(cursorlinex,tlorigo_y,cursorlinex,tlorigo_y+tlh);
            draw_set_alpha(1);
        }
    }
    draw_set_color(c_white);
    
    
    //frame box
    draw_ilda_2d();
    
    if (!laseron)
    {
        if (bckimage)
        {
            if (!keyboard_check(ord('E')))
                draw_set_alpha(0.3);
            if (sprite_exists(bck_bckimage))
            {
                draw_sprite_stretched(bck_bckimage,0,bckimage_left,bckimage_top,bckimage_width,bckimage_height);
            }
            else bckimage = 0;
        }
        
        if (object_select_hovering = 1)
        {
            draw_set_alpha(0.5);
            draw_set_colour(c_teal);
                draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
            draw_set_alpha(1);
            draw_set_colour(c_white);
        }
        else if (object_select_hovering = 2)
        {
            draw_set_alpha(0.7);
            draw_set_colour(c_maroon);
                draw_rectangle(rectxmin2,rectymin2,rectxmax2,rectymax2,1);
            draw_set_alpha(1);
            draw_set_colour(c_white);
        }
        
        draw_set_color(c_gray);
        if (objmoving == 3)
            draw_text(20,20,string_format(anirot,3,2)+" deg");
        else if (objmoving == 1)
        {
            draw_text(20,20,"X translation: "+string_format(anixtrans,5,0));
            draw_text(20,40,"Y translation: "+string_format(aniytrans,5,0));
        }
        else if (objmoving == 2)
        {
            draw_text(20,20,"Anchor X: "+string_format(anchorx,5,0));
            draw_text(20,40,"Anchor Y: "+string_format(anchory,5,0));
        }
        else if (objmoving == 4)
        {
            draw_text(20,20,"X scale: "+string_format(scalex,2,3));
            draw_text(20,40,"Y scale: "+string_format(scaley,2,3));
        }
        draw_set_color(c_white);
            
        draw_set_alpha(0.7);
           
        //grids 
        if (keyboard_check(ord('S')) or (sgridshow == 1))
        {
            if (!surface_exists(squaregrid_surf))
            {
                squaregrid_surf = surface_create(512,512);
                surface_set_target(squaregrid_surf);
                    draw_grid();
                surface_reset_target();
            }
            draw_surface(squaregrid_surf,0,0);
        } 
        if (keyboard_check(ord('R')) or (rgridshow == 1))
        {
            if (!surface_exists(radialgrid_surf))
            {
                radialgrid_surf = surface_create(512,512);
                surface_set_target(radialgrid_surf);
                    draw_radialgrid();
                surface_reset_target();
            }
            draw_surface(radialgrid_surf,0,0);
        }
            
        if (keyboard_check(ord('A')) or (guidelineshow == 1))
        {
            draw_guidelines();
        }
            
        draw_set_alpha(1);
        
        //selected elements
        draw_set_color(c_aqua);
        if !(ds_list_empty(semaster_list))//(selectedelement != -1)
        {
            if (update_semasterlist_flag)
                update_semasterlist();
            
            draw_sprite(spr_anchor,0,round(anchorx/$ffff*512),round(anchory/$ffff*512));
            draw_set_alpha(0.6);
            draw_sprite(spr_rotate,0,rectxmin,rectymax);
            draw_sprite(spr_resize,0,rectxmax,rectymax);
            draw_set_alpha(1);
            
            draw_rectangle(rectxmin,rectymin,rectxmax,rectymax,1);
            
            if (objmoving == 1) or (objmoving == 3) or (objmoving == 4)
            {
                xp1 = rectxmin+anixtrans/$ffff*512;
                yp1 = rectymin+aniytrans/$ffff*512;
                xp2 = rectxmax+anixtrans/$ffff*512;
                yp2 = rectymax+aniytrans/$ffff*512;
                xp3 = rectxmax+anixtrans/$ffff*512;
                yp3 = rectymin+aniytrans/$ffff*512;
                xp4 = rectxmin+anixtrans/$ffff*512;
                yp4 = rectymax+aniytrans/$ffff*512;
                rot_r = degtorad(anirot);
                
                angle1 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1));
                dist1 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp1,yp1);
                
                xpnew1 = anchorx/$ffff*512+cos(rot_r-angle1)*dist1*scalex;
                ypnew1 = anchory/$ffff*512+sin(rot_r-angle1)*dist1*scaley;
                
                angle2 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2));
                dist2 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp2,yp2);
                
                xpnew2 = anchorx/$ffff*512+cos(rot_r-angle2)*dist2*scalex;
                ypnew2 = anchory/$ffff*512+sin(rot_r-angle2)*dist2*scaley;
        
                angle3 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3));
                dist3 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp3,yp3);
                
                xpnew3 = anchorx/$ffff*512+cos(rot_r-angle3)*dist3*scalex;
                ypnew3 = anchory/$ffff*512+sin(rot_r-angle3)*dist3*scaley;
                
                angle4 = degtorad(point_direction(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4));
                dist4 = point_distance(anchorx/$ffff*512,anchory/$ffff*512,xp4,yp4);
                
                xpnew4 = anchorx/$ffff*512+cos(rot_r-angle4)*dist4*scalex;
                ypnew4 = anchory/$ffff*512+sin(rot_r-angle4)*dist4*scaley;
                
        
                draw_set_color(c_teal);
                draw_rectangle(xp1,yp1,xp2,yp2,1);
                
                draw_line(xpnew1,ypnew1,xpnew3,ypnew3);
                draw_line(xpnew2,ypnew2,xpnew3,ypnew3);
                draw_line(xpnew2,ypnew2,xpnew4,ypnew4);
                draw_line(xpnew4,ypnew4,xpnew1,ypnew1);
            
                if (objmoving == 1)
                {
                    draw_set_alpha(0.4);
                        draw_arrow(mean(rectxmin,rectxmax),mean(rectymin,rectymax),mean(xpnew1,xpnew2),mean(ypnew1,ypnew2),12);
                    draw_set_alpha(1);
                }
            }
            
        }
        
        if (placing_status) or (placing == "text") or (placing == "hershey") 
            draw_preview_element();
    }
    
    //info text
    draw_set_alpha(0.8);
    draw_set_font(fnt_tooltip);
    
        draw_set_color(c_ltgray);
        draw_text(12,495,"Frame: "+string(frame+1)+"/"+string(maxframes));
        
        draw_text(12,7,"FPS: "+string(projectfps));
        if (playing &amp;&amp; (fps != projectfps))
        {
            draw_set_color(c_red);
            draw_text(32,7,"Warning: Dropping frames. Actual FPS: "+string(fps));
        }
        
        if (frame_complexity == 1)
            draw_set_color(c_red);
        else if (frame_complexity == 2)
            draw_set_color(c_orange);
        else 
            draw_set_color(c_ltgray);
        draw_text(440,495,"Points: "+string(framepoints));
        
        if (!anienable) and (maxframes &lt; 2)
            draw_set_color(c_gray);
        else 
            draw_set_color(c_ltgray);
        if (scope_start == 0) and (scope_end == maxframes-1)
            draw_text(220,495,"Scope: All frames");
        else
            draw_text(220,495,"Scope: "+string(scope_start+1)+" - "+string(scope_end+1));
            
    draw_set_colour(c_black);
    draw_set_alpha(1);
    
    draw_enable_alphablend(0);
    with (obj_button_parent)
    {
        draw_self();
    }
    draw_enable_alphablend(1);
}
else if (view_current == 3)
{
    draw_set_colour(c_black);
    draw_set_alpha(1);
    
    //menu
    draw_text(0,view_yview[3]+4,menu_string);
    if (mouse_y &gt; view_yview[3])   
    {
        draw_set_colour(c_teal);
        if (mouse_x &gt; menu_width_start[0]) and (mouse_x &lt; menu_width_start[1])
        {
            draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[0],view_yview[3]+1,menu_width_start[1],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[1]) and (mouse_x &lt; menu_width_start[2])
        {
            draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[1],view_yview[3]+1,menu_width_start[2],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[2]) and (mouse_x &lt; menu_width_start[3])
        {
            draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[2],view_yview[3]+1,menu_width_start[3],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[3]) and (mouse_x &lt; menu_width_start[4])
        {
            draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[3],view_yview[3]+1,menu_width_start[4],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[4]) and (mouse_x &lt; menu_width_start[5])
        {
            draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[4],view_yview[3]+1,menu_width_start[5],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[5]) and (mouse_x &lt; menu_width_start[6])
        {
            draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[5],view_yview[3]+1,menu_width_start[6],view_yview[3]+20,0);
        }
        else if (mouse_x &gt; menu_width_start[6]) and (mouse_x &lt; menu_width_start[7])
        {
            draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,1);
            draw_set_alpha(0.3);
            draw_rectangle(menu_width_start[6],view_yview[3]+1,menu_width_start[7],view_yview[3]+20,0);
        }
        draw_set_alpha(1);
    }
    draw_set_colour(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="48">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
frame = 0;
framehr = 0;
frame_surf_refresh = 1;


ds_list_clear(semaster_list);
update_semasterlist_flag = 1;

if (seqcontrol.song)
    FMODInstanceSetPaused(seqcontrol.songinstance,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room != rm_ilda) exit;
if (placing == "curve") and (placing_status == 2)
    create_element();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
